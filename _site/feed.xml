<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-07-25T11:40:02+09:00</updated><id>http://localhost:4000/</id><title type="html">k3y6reak</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</subtitle><entry><title type="html">Save Frame Pointer Overwrite</title><link href="http://localhost:4000/technique/system_hacking/2017/07/25/Save_Frame_Pointer_Overwrite.html" rel="alternate" type="text/html" title="Save Frame Pointer Overwrite" /><published>2017-07-25T10:05:00+09:00</published><updated>2017-07-25T10:05:00+09:00</updated><id>http://localhost:4000/technique/system_hacking/2017/07/25/Save_Frame_Pointer_Overwrite</id><content type="html" xml:base="http://localhost:4000/technique/system_hacking/2017/07/25/Save_Frame_Pointer_Overwrite.html">&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;개념&quot;&gt;개념&lt;/h3&gt;

&lt;p&gt;Buffer Overflow가 발생하는 프로그램의 취약점을 이용하여 Save Frame Pinter를 덮어씌워 원하는 주소로 이동하는 방법을 말합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;설명&quot;&gt;설명&lt;/h3&gt;

&lt;p&gt;Buffer Overflow에서 잠깐 언급했던 Save Frame Pointer(SFP)는 &lt;code class=&quot;highlighter-rouge&quot;&gt;이전 함수의 ebp&lt;/code&gt;를 저장해 두고 함수의 실행이 끝나면 돌아가는 역할을 했습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Main Func&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;sub_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sub_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;scanf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 소스코드를 보면 main 함수에서는 출력과 sub_func()을 호출하고 sub_func 함수에서는 buf가 8개의 공간이 할당되었고 scanf를 이용해 buf에 값을 저장합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;Dump of assembler code &lt;span class=&quot;k&quot;&gt;for function &lt;/span&gt;main:
0x0804846d &amp;lt;+0&amp;gt;:	push	ebp
0x0804846e &amp;lt;+1&amp;gt;:	mov 	ebp,esp
0x08048470 &amp;lt;+3&amp;gt;:	sub 	esp,0x4
0x08048473 &amp;lt;+6&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],0x8048540
0x0804847a &amp;lt;+13&amp;gt;:	call	0x8048330 &amp;lt;puts@plt&amp;gt;
0x0804847f &amp;lt;+18&amp;gt;:	call	0x804848b &amp;lt;sub_func&amp;gt;
0x08048484 &amp;lt;+23&amp;gt;:	mov	eax,0
0x08048489 &amp;lt;+28&amp;gt;:	leave
0x0804848a &amp;lt;+29&amp;gt;:	ret
End of assembler dump.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 어셈블리 코드에서 puts와 sub_func의 호출을 볼 수 있으며 puts를 호출하기 전 esp에 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x8048540&lt;/code&gt; 값을 저장하고 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/s 0x8048540
0x8048540:	&lt;span class=&quot;s2&quot;&gt;&quot;Main Func&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x804847f&lt;/code&gt;에 Breakpoint를 걸고 해당 주소까지 실행해 보도록 하겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;Dump of assembler code &lt;span class=&quot;k&quot;&gt;for function &lt;/span&gt;main:
	0x0804846d &amp;lt;+0&amp;gt;:	push	ebp
	0x0804846e &amp;lt;+1&amp;gt;:	mov 	ebp,esp
	0x08048470 &amp;lt;+3&amp;gt;:	sub 	esp,0x4
	0x08048473 &amp;lt;+6&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],0x8048540
	0x0804847a &amp;lt;+13&amp;gt;:	call	0x8048330 &amp;lt;puts@plt&amp;gt;
&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;gt;	0x0804847f &amp;lt;+18&amp;gt;:	call	0x804848b &amp;lt;sub_func&amp;gt;
	0x08048484 &amp;lt;+23&amp;gt;:	mov	eax,0
	0x08048489 &amp;lt;+28&amp;gt;:	leave
	0x0804848a &amp;lt;+29&amp;gt;:	ret
End of assembler dump.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;해당 위치에서 esp 부터 10개의 값은 아래와 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/10wx &lt;span class=&quot;nv&quot;&gt;$esp&lt;/span&gt;
0xbffff154:	0x08048540	0x00000000	0xb7e2fa83	0x00000001
0xbffff164:	0xbffff1f4	0xbffff1fc	0xb7feccea	0x00000001
0xbffff174:	0xbffff1f4	0xbffff194&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이제 여기서 sub_func 함수 안으로 들어가 보도록 하겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;Dump of assembler code &lt;span class=&quot;k&quot;&gt;for function &lt;/span&gt;sub_func:
&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;gt;	0x0804848b &amp;lt;+0&amp;gt;:	push	ebp
	0x0804848c &amp;lt;+1&amp;gt;:	mov 	ebp,esp
	0x0804848e &amp;lt;+3&amp;gt;:	sub 	esp,0x10
	0x08048491 &amp;lt;+6&amp;gt;:	lea	eax,[ebp-0x8]
	0x08048494 &amp;lt;+9&amp;gt;:	mov	DWORD PTR[esp+0x4],eax
	0x08048498 &amp;lt;+13&amp;gt;:	mov	DWORD PTR[esp],0x804854b
	0x0804849f &amp;lt;+20&amp;gt;:	call	0x8048360 &amp;lt;__isoc99_scanf@plt&amp;gt;
	0x080484a4 &amp;lt;+25&amp;gt;:	leave
	0x080484a5 &amp;lt;+26&amp;gt;:	ret
End of assembler dump.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;sub_func 함수 내로 들어온 후 esp 값을 확인해보면 아래와 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/10wx &lt;span class=&quot;nv&quot;&gt;$esp&lt;/span&gt;
0xbffff150:	0x08048484	0x08048540	0x00000000	0xb7e2fa83
0xbffff160:	0x00000001	0xbffff1f4	0xbffff1fc	0xb7feccea
0xbffff170:	0x00000001	0xbffff1f4&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;스택에 쌓여진 값을 살펴보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x8048484&lt;/code&gt;라는 값을 확인할 수 있는데 이 값은 main함수에서 sub_func이 있는 곳의 다음 주소를 나타냅니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;다음 주소를 쌓아두는 이유는 sub_func 함수가 끝나면 main에서 다음 코드를 실행해야 하기 때문에 쌓아둔 것&lt;/code&gt;이며 이 값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;Return&lt;/code&gt;값이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x804849f&lt;/code&gt;에 Breakpoint를 걸고 해당 주소까지 실행 후 스택을 확인해 보도록 하겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;Dump of assembler code &lt;span class=&quot;k&quot;&gt;for function &lt;/span&gt;sub_func:
	0x0804848b &amp;lt;+0&amp;gt;:	push	ebp
	0x0804848c &amp;lt;+1&amp;gt;:	mov 	ebp,esp
	0x0804848e &amp;lt;+3&amp;gt;:	sub 	esp,0x10
	0x08048491 &amp;lt;+6&amp;gt;:	lea	eax,[ebp-0x8]
	0x08048494 &amp;lt;+9&amp;gt;:	mov	DWORD PTR[esp+0x4],eax
	0x08048498 &amp;lt;+13&amp;gt;:	mov	DWORD PTR[esp],0x804854b
&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;gt;	0x0804849f &amp;lt;+20&amp;gt;:	call	0x8048360 &amp;lt;__isoc99_scanf@plt&amp;gt;
	0x080484a4 &amp;lt;+25&amp;gt;:	leave
	0x080484a5 &amp;lt;+26&amp;gt;:	ret
End of assembler dump.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/10wx &lt;span class=&quot;nv&quot;&gt;$esp&lt;/span&gt;
0xbffff13c:	0x0804854b	0xbffff144	0x00000000	0x00000000
0xbffff14c:	0xbffff158	0x08048484	0x08048540	0x00000000
0xbffff15c:	0xb7e2fa83	0x00000001&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;scanf 함수가 사용하는 인자 값은 2개이기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x804854b&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xbffff144&lt;/code&gt;가 인자 값이 됩니다.
0x804854b는 &lt;code class=&quot;highlighter-rouge&quot;&gt;%s&lt;/code&gt;가 되며 0xbffff144는 &lt;code class=&quot;highlighter-rouge&quot;&gt;buf의 주소&lt;/code&gt;가 됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/10wx 0xbffff144
0xbffff144:	0x00000000	0x00000000	0xbffff158	0x08048484
0xbffff154:	0x08048540	0x00000000	0xb7e2fa83	0x00000001
0xbffff164:	0xbffff1f4	0xbffff1fc&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;0xbffff144의 스택을 살펴보면 아직 scanf가 실행되지 않았기 때문에 값이 0x00000000로 되어있는 것을 알 수 있습니다. scanf가 실행되고 난 뒤를 실펴보기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;ni&lt;/code&gt;명령으로 실행 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;12345678&lt;/code&gt;값을 입력하고 다시 스택을 살펴보면 아래와 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/10wx 0xbffff144
0xbffff144:	0x34333231	0x38373635	0xbffff100	0x08048484
0xbffff154:	0x08048540	0x00000000	0xb7e2fa83	0x00000001
0xbffff164:	0xbffff1f4	0xbffff1fc&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;buf의 다음은 Save Frame Pointer 이므로 0xbffff100이 Save Frame Pointer가 됩니다.&lt;/p&gt;

&lt;p&gt;값을 입력하기 전에 SFP의 값은 0xbffff158 이었는데 0xbffff100으로 바뀐 이유는 문자열을 입력하면서 &lt;code class=&quot;highlighter-rouge&quot;&gt;마지막에 Null이 포함&lt;/code&gt;된 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;이해&quot;&gt;이해&lt;/h3&gt;
&lt;p&gt;LOB의 golem 소소코드를 이용하여 SFP를 실습해 보도록 하겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;proglem_child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;strncpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;41&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;argv error&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;prolem_child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;main 함수에서 argv로 인자 값을 받아오고 해당 값을 problem_child 함수에서 src로 받습니다.
src로 받은 값을 buffer에 41개 만큼 저장합니다.&lt;/p&gt;

&lt;p&gt;여기서 중요한 것은 &lt;code class=&quot;highlighter-rouge&quot;&gt;buffer의 크기는 40인데 strncpy를 이용해 41개를 넣어주는 것입니다.&lt;/code&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;pdisas main
Dump of assembler code &lt;span class=&quot;k&quot;&gt;for function &lt;/span&gt;main:
	0x080484aa &amp;lt;+0&amp;gt;:	push	ebp
	0x080484ab &amp;lt;+1&amp;gt;:	mov 	ebp,esp
	0x080484ad &amp;lt;+3&amp;gt;:	sub 	esp,0x4
	0x080484b0 &amp;lt;+6&amp;gt;:	cmp	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;ebp+0x8],0x1
	0x080484b4 &amp;lt;+10&amp;gt;:	jg	0x80484ce &amp;lt;main+36&amp;gt;
	0x080484b6 &amp;lt;+12&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],0x8048570
	0x080484bd &amp;lt;+19&amp;gt;:	call	0x8048330 &amp;lt;puts@plt&amp;gt;
	0x080484c2 &amp;lt;+24&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],0x0
	0x080484c9 &amp;lt;+31&amp;gt;:	call	0x8048350 &amp;lt;&lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;@plt&amp;gt;
	0x080484ce &amp;lt;+36&amp;gt;:	mov	eax, DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;ebp+0xc]
	0x080484d1 &amp;lt;+39&amp;gt;:	add 	eax,0x4
	0x080484d4 &amp;lt;+42&amp;gt;:	mov	eax,DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;eax]
	0x080484d6 &amp;lt;+44&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],eax
	0x080484d9 &amp;lt;+47&amp;gt;:	call	0x804847d &amp;lt;problem_child&amp;gt;
	0x080484de &amp;lt;+52&amp;gt;:	leave
	0x080484df &amp;lt;+53&amp;gt;:	ret
End of assembler dump.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;problem_child 위치에 Breakpoint를 걸고 `python -c ‘print “A”*40 + “B”’`를 이용해 argv[1]에 값을 넣고 problem_child 함수 안으로 들어갑니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;Dump of assembler code &lt;span class=&quot;k&quot;&gt;for function &lt;/span&gt;problem_child:
&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;gt;	0x0804847d &amp;lt;+0&amp;gt;:	push	ebp
	0x0804847e &amp;lt;+1&amp;gt;:	mov 	ebp,esp
	0x08048480 &amp;lt;+3&amp;gt;:	sub 	esp,0x34
	0x08048483 &amp;lt;+6&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp+0x8],0x29
	0x0804848b &amp;lt;+14&amp;gt;:	mov	eax,DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;ebp+0x8]
	0x0804848e &amp;lt;+17&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp+0x4],eax
	0x08048492 &amp;lt;+21&amp;gt;:	lea 	eax,[ebp-0x28]
	0x08048495 &amp;lt;+24&amp;gt;:	mov 	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],eax
	0x08048498 &amp;lt;+27&amp;gt;:	call 	0x8048370 &amp;lt;strncpy@plt&amp;gt;
	0x0804849d &amp;lt;+32&amp;gt;:	lea 	eax,[ebp-0x28]
	0x080484a0 &amp;lt;+35&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],eax
	0x080484a3 &amp;lt;+38&amp;gt;:	call	0x8048330 &amp;lt;puts@plt&amp;gt;
	0x080484a8 &amp;lt;+43&amp;gt;:	leave
	0x080484a9 &amp;lt;+44&amp;gt;:	ret
End of assembler dump.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x804849d&lt;/code&gt;에 Breakpoint를 걸고 buf의 값을 확인해 보도록 하겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;Dump of assembler code &lt;span class=&quot;k&quot;&gt;for function &lt;/span&gt;problem_child:
	0x0804847d &amp;lt;+0&amp;gt;:	push	ebp
	0x0804847e &amp;lt;+1&amp;gt;:	mov 	ebp,esp
	0x08048480 &amp;lt;+3&amp;gt;:	sub 	esp,0x34
	0x08048483 &amp;lt;+6&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp+0x8],0x29
	0x0804848b &amp;lt;+14&amp;gt;:	mov	eax,DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;ebp+0x8]
	0x0804848e &amp;lt;+17&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp+0x4],eax
	0x08048492 &amp;lt;+21&amp;gt;:	lea 	eax,[ebp-0x28]
	0x08048495 &amp;lt;+24&amp;gt;:	mov 	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],eax
	0x08048498 &amp;lt;+27&amp;gt;:	call 	0x8048370 &amp;lt;strncpy@plt&amp;gt;
	0x0804849d &amp;lt;+32&amp;gt;:	lea 	eax,[ebp-0x28]
	0x080484a0 &amp;lt;+35&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],eax
	0x080484a3 &amp;lt;+38&amp;gt;:	call	0x8048330 &amp;lt;puts@plt&amp;gt;
	0x080484a8 &amp;lt;+43&amp;gt;:	leave
	0x080484a9 &amp;lt;+44&amp;gt;:	ret
End of assembler dump.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/10wx &lt;span class=&quot;nv&quot;&gt;$ebp&lt;/span&gt;-0x28
0xbffff0f4:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff104:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff114:	0x41414141	0x41414141	0xbffff142 	0x080484de
0xbffff124:	0xbffff39f	0x00000000 	0xb7e2fa83 	0x00000002
0xbffff134:	0xbffff1c4	0xbffff1d0	0xb7feccea	0x00000002&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;40개의 A와 B를 넣었더니 위와 같이 buf에 값이 채워졌습니다. 그리고 SFP의 값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xbffff142&lt;/code&gt;로 변조된 것도 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 변조된 값을 &lt;code class=&quot;highlighter-rouge&quot;&gt;함수의 에필로그&lt;/code&gt;를 이용하여 리턴 값을 조작할 수 있습니다.&lt;/p&gt;

&lt;p&gt;함수의 에필로그는 &lt;code class=&quot;highlighter-rouge&quot;&gt;leave&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;ret&lt;/code&gt;이 있는데 이 어셈블리어는 각각 &lt;code class=&quot;highlighter-rouge&quot;&gt;mov esp, ebp&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;pop ebp&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;pop eip&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;jmp eip&lt;/code&gt;가 됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;pdisas main
Dump of assembler code &lt;span class=&quot;k&quot;&gt;for function &lt;/span&gt;main:
	0x080484aa &amp;lt;+0&amp;gt;:	push	ebp
	0x080484ab &amp;lt;+1&amp;gt;:	mov 	ebp,esp
	0x080484ad &amp;lt;+3&amp;gt;:	sub 	esp,0x4
	0x080484b0 &amp;lt;+6&amp;gt;:	cmp	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;ebp+0x8],0x1
	0x080484b4 &amp;lt;+10&amp;gt;:	jg	0x80484ce &amp;lt;main+36&amp;gt;
	0x080484b6 &amp;lt;+12&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],0x8048570
	0x080484bd &amp;lt;+19&amp;gt;:	call	0x8048330 &amp;lt;puts@plt&amp;gt;
	0x080484c2 &amp;lt;+24&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],0x0
	0x080484c9 &amp;lt;+31&amp;gt;:	call	0x8048350 &amp;lt;&lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;@plt&amp;gt;
	0x080484ce &amp;lt;+36&amp;gt;:	mov	eax, DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;ebp+0xc]
	0x080484d1 &amp;lt;+39&amp;gt;:	add 	eax,0x4
	0x080484d4 &amp;lt;+42&amp;gt;:	mov	eax,DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;eax]
	0x080484d6 &amp;lt;+44&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],eax
	0x080484d9 &amp;lt;+47&amp;gt;:	call	0x804847d &amp;lt;problem_child&amp;gt;
&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;gt;	0x080484de &amp;lt;+52&amp;gt;:	leave
	0x080484df &amp;lt;+53&amp;gt;:	ret
End of assembler dump.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;main에서 leave 위치까지 실행한 뒤에 ebp와 esp를 확인하면 아래와 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;i r ebp
ebp 	0xbffff142 	0xbffff142&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;ebp를 확인한 결과 조작된 0xbffff142가 되었습니다. 여기서 leave 명령을 실행하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;mov esp,ebp&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;pop ebp&lt;/code&gt; 이므로 ebp의 값을 esp로 옮기고 pop하여 ebp에 저장합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;i r ebp esp
ebp 	0xf1c40000 	0xf1c40000
esp 	0xbffff146 	0xbffff146&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;변조 된 ebp 값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;mov esp, ebp&lt;/code&gt;를 통해서 esp에 저장이 되었고 &lt;code class=&quot;highlighter-rouge&quot;&gt;pop ebp&lt;/code&gt;를 하면서 +4 만큼 증가되었습니다.&lt;/p&gt;

&lt;p&gt;그래서 esp의 값이 0xbffff146이 됩니다. (0xbffff142 + 0x4)&lt;/p&gt;

&lt;p&gt;그 후 0xbffff146에 있는 값을 &lt;code class=&quot;highlighter-rouge&quot;&gt;pop eip&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;jmp eip&lt;/code&gt;하면서 해당 위치로 이동하게 됩니다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;code class=&quot;highlighter-rouge&quot;&gt;|shellcode 주소|\x90*n|shellcode|stack 주소 - 0x4|&lt;/code&gt;와 같은 payload를 사용할 수 있습니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">개념</summary></entry><entry><title type="html">Buffer Overflow</title><link href="http://localhost:4000/technique/system_hacking/2017/07/24/Buffer_OverFlow.html" rel="alternate" type="text/html" title="Buffer Overflow" /><published>2017-07-24T15:03:00+09:00</published><updated>2017-07-24T15:03:00+09:00</updated><id>http://localhost:4000/technique/system_hacking/2017/07/24/Buffer_OverFlow</id><content type="html" xml:base="http://localhost:4000/technique/system_hacking/2017/07/24/Buffer_OverFlow.html">&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;개념&quot;&gt;개념&lt;/h3&gt;

&lt;p&gt;Buffer Overflow (이하 bof)는 크기가 정해진 배열에 해당 크기 만큼 입력해야 하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;버퍼보다 큰 값&lt;/code&gt;
을 넣을 수 있는 취약점을 말합니다.&lt;/p&gt;

&lt;p&gt;예를들어, &lt;code class=&quot;highlighter-rouge&quot;&gt;char buf[10]&lt;/code&gt;로 선언했다면 buf는 총 10개의 공간을 갖게 됩니다. 하지만 프로그램이 실행 되면서 buf에 10개가 아닌 11개, 12개 혹은 그 이상의 값이 들어가는 것을 확인하지 않고 실행 하므로서 발생하는 취약점을 뜻 합니다.&lt;/p&gt;

&lt;p&gt;그래서 bof는 stack corruption으로도 불립니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;설명&quot;&gt;설명&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;scanf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 소스코드를 보면 buf라는 char 배열에 총 8개의 값을 넣을 수 있고, scanf를 이용해서 buf에 값을 넣어줍니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;scanf()&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;크기 제한&lt;/code&gt;이 없기 때문에 해당 부분에서 취약점이 발생할 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;Dump of assembler code &lt;span class=&quot;k&quot;&gt;for function &lt;/span&gt;main:
0x0804843d &amp;lt;+0&amp;gt;:	push	ebp
0x0804843e &amp;lt;+1&amp;gt;:	mov 	ebp,esp
0x08048440 &amp;lt;+3&amp;gt;:	sub 	esp,0x10
0x08048443 &amp;lt;+6&amp;gt;:	lea 	eax,[ebp-0x8]
0x08048446 &amp;lt;+9&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp+0x4],eax
0x0804844a &amp;lt;+13&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp], 0x80484f0
0x08048451 &amp;lt;+20&amp;gt;:	call	0x80484330 &amp;lt;__isoc99_scanf@plt&amp;gt;
0x08048456 &amp;lt;+25&amp;gt;:	mov	eax,0x0
0x0804845b &amp;lt;+30&amp;gt;:	leave
0x0804845c &amp;lt;+31&amp;gt;:	ret
End of assembler dump.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 코드에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;push ebp&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;mov ebp,esp&lt;/code&gt;가 함수의 프롤로그가 되며, &lt;code class=&quot;highlighter-rouge&quot;&gt;leave&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ret&lt;/code&gt;이 함수의 에필로그가 됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;0x08048446 &amp;lt;+9&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp+0x4],eax
0x0804844a &amp;lt;+13&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp], 0x80484f0
0x08048451 &amp;lt;+20&amp;gt;:	call	0x80484330 &amp;lt;__isoc99_scanf@plt&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;스택 구조에 대해서 설명을 붙이자면 위 어셈블리 코드를 보면 scanf가 실행되기 전 &lt;code class=&quot;highlighter-rouge&quot;&gt;esp&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;esp+0x4&lt;/code&gt;에 값을 넣고 있는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;scanf&lt;/code&gt;함수는 보통 &lt;code class=&quot;highlighter-rouge&quot;&gt;scanf(&quot;%s&quot;, buf)&lt;/code&gt; 형태로 코드를 작성합니다.&lt;/p&gt;

&lt;p&gt;여기서 &lt;code class=&quot;highlighter-rouge&quot;&gt;%s&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;buf&lt;/code&gt;가 &lt;code class=&quot;highlighter-rouge&quot;&gt;인자 값&lt;/code&gt;이 되기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;esp&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;esp+0x4&lt;/code&gt;에 값을 넣어주게 됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/2wx &lt;span class=&quot;nv&quot;&gt;$esp&lt;/span&gt;
0xbffff148:	0x080484f0	0xbffff150
&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/s 0x80484f0
0x80484f0:	&lt;span class=&quot;s2&quot;&gt;&quot;%s&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;esp 위치부터 2개가 값을 확인해 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x80484f0&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xbffff150&lt;/code&gt;이 있습니다. scanf가 필요한 인자 값이 2개 이므로 각각 &lt;code class=&quot;highlighter-rouge&quot;&gt;%s&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;buf&lt;/code&gt;를 뜻하게 됩니다.&lt;/p&gt;

&lt;p&gt;scanf를 실행한 뒤에 buf의 주소를 확인해 보면 값이 쌓여있는 것을 알 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/10wx 0xbffff150
0xbffff150:	0x34333231	0x00000000	0x00000000	0xb7e1fa83
0xbffff160:	0x00000001	0xbffff1f4	0xbffff1fc	0xb7feccea
0xbffff170:	0x00000001	0xbffff1f4&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1234&lt;/code&gt;라는 값을 입력했더니 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x34333231&lt;/code&gt;라는 값이 저장되었습니다. 1234라는 값이 각각 hex 값으로 저장된 것입니다. 하지만 ascii 코드를 살펴보면 4321 순으로 저장된 것을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;이는 &lt;code class=&quot;highlighter-rouge&quot;&gt;리틀엔디안과 빅엔디안&lt;/code&gt;차이에 따라서 결정됩니다.&lt;/p&gt;

&lt;p&gt;코드를 하나씩 살펴보면서 값이 어떻게 저장되는지 확인해 봤습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;scanf&lt;/code&gt;함수에서 취약점이 발생한다고 했으니 어떻게 되는지 알아보도록 하겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/4wx 0xbffff150
0xbffff150:	0x34333231	0x38373635	0x00000000	0xb7e1fa83&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이번에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;12345678&lt;/code&gt;을 입력했습니다. 위 스택을 살펴보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;4321 8765&lt;/code&gt; 순으로 쌓인 것을 알 수 있으며 buf의 크기가 8인데 8자리를 모두 사용했습니다.&lt;/p&gt;

&lt;p&gt;여기서 &lt;code class=&quot;highlighter-rouge&quot;&gt;scanf 함수는 크기를 제한하지 않으므로&lt;/code&gt; 값을 더 입력해 보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/4wx 0xbffff150
0xbffff150:	0x34333231	0x38373635	0x32313039	0x36353433&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;값을 더 입력했더니 뒤에 존재했던 값들이 모두 덮어 씌워졌습니다.&lt;/p&gt;

&lt;p&gt;이 상태에서 프로그램을 진행 시키면 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x36353433 in ?? ()&lt;/code&gt; 과 같이 나타납니다. 이 말은 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x36353433 주소로 이동&lt;/code&gt;을 했다는 것 입니다.&lt;/p&gt;

&lt;p&gt;이제 여기서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Save Frame Pointer&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;Return&lt;/code&gt;을 알아야 합니다.&lt;/p&gt;

&lt;p&gt;Save Frame Pointer는 &lt;code class=&quot;highlighter-rouge&quot;&gt;이전함수에서의 ebp 값을 저장&lt;/code&gt;해 둡니다. 해당 함수가 실행되고 난 후에 다시 돌아가야 할 때 이 값을 기준으로 돌아가게 됩니다.&lt;/p&gt;

&lt;p&gt;Return은 해당 주소로 이동하는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/system_hacking/bof/stack.png&quot; alt=&quot;stack&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Stack의 구조는 위와 같이 이루어져 있기 때문에 앞서 값을 넘치게 입력했을 경우 0x36353433로 이동하게 된 것입니다.&lt;/p&gt;

&lt;p&gt;이러한 방법으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;RET 값을 조작해서 system 함수를 호출하거나 프로그램 상에서 호출되지 않는 함수에도 접근이 가능&lt;/code&gt;하게 됩니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">개념</summary></entry></feed>